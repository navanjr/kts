create proc dbo.receiptVoid(
 @receiptId int,
 @debugMode varchar(5) = 'FALSE'
) as 
begin
 exec dbo.logit @@procid, '@receiptId', @receiptId

 declare
  @postDate int,
  @fpId int,
  @resultCode int,
  @newId int,
  @receiptSlink varchar(15) = 'o' + cast(@receiptId as varchar),
  @jeDescription varchar(50) = 'Credit/Void receipt id:' + cast(@receiptId as varchar),
  @log varchar(max),
  @jeId int 

-- get the postdate
 select @postdate = dbo.clariondate(getDate())
 
 select @fpId = dbo.glGetFiscalPeriodid(@postDate)

 exec dbo.logit @@procid, '@receiptSlink', @receiptSlink

 -- bail if the period is closed
 if isnull(@fpId,0) < 1
 begin
  exec dbo.logit @@procid, 'Period closed... @fpid', @fpid
  select '@code=1;@message=Fiscal Period is closed... You can not void this receipt.'
  return
 end

 -- bail if this has already been voided/canceled
 if exists (select * from dbo.journalLink where receiptid = @receiptId)
 begin
  select top 1 @jeId = jeId from dbo.journalLink where @receiptId = @receiptId
  exec dbo.logit @@procid, 'Appears Void already exists... @jeId', @jeId
  select '@code=1;@message=Void already exists... Can not continue.'
  return
 end

 -- bail if effected payments have already been deposited
 if exists(select * from paid where slink = @receiptSlink and depositId > 0)
 begin
  exec dbo.logit @@procid, 'Can not void this receipt as it has already been attached to a deposit.'
  select '@code=1;@message=Sorry, Receipt linked to a deposit can not be voided.;'
  return
 end

 -- TODO: bail if there is no balance. like if it was done wrong

 -- TODO: dont forget a sql transaction

 -- ok so for now we will just will erase all the glDetail and flag the receipt, invoices and payments as VOID

 
 exec dbo.receiptCRUD 3, @receiptId, @voidReceipt = 'TRUE', @deletePosted = 'TRUE' 








-- TODO: void by reversing entry
/* this code is for voiding items by reversing entries.  We have decided to use this method in the future, but not yet.
 -- create JE with Staged GL Detail and link it to the receipt and then post it
 declare @wt table(
  id int identity(1,1),
  accountId int,
  accountCode varchar(50),
  accountDesc varchar(50),
  accountType varchar(50),
  amount money,
  contraId int,
  targetId int,
  processFlag int default 0
 ) 
 insert @wt (accountCode,amount,contraId,targetId) 
 select postAccountCode, postAmount, contraId, targetId from dbo.receiptVoidBRW(@receiptId) where postFlag = 1
 declare 
  @idToken int,
  @accountidToken int,
  @accountCodeToken varchar(50),
  @accountDescToken varchar(50),
  @accountTypeToken varchar(50)

 update @wt set accountType = (select accountType from dbo.glAccountTypes(accountCode,'',''))
 
 
 while exists ( select * from @wt where processFlag = 0 )
 begin
  select top 1
   @idToken = id,
   @accountCodeToken = accountCode,
   @accountTypeToken = accountType
  from @wt where processFlag = 0

  exec dbo.glAccountVerification
   @accountCodeToken,
   @accountTypeToken,
   'create',
   @accountid = @accountIdToken output,
   @accountDesc = @accountDescToken output

  update @wt set
   accountId = @accountIdToken,
   accountDesc = @accountDescToken,
   processFlag = 1 
  where id = @idToken

-- wont need this anymore
--  select @log = 'accountId=' + cast(@accountIdToken as varchar) + ';' + 'accountDesc=' + @accountDescToken + ';'
--  exec dbo.logit @@procId, 'ran thru glAccountVerification', @log


 end

-- check the wt for records sufficenat to proceed
 select @log = 'wt count:' + cast(isnull(count(*),0) as varchar) from @wt
 exec dbo.logit @@procid, @log
 if not exists(select * from @wt)
  return

 if @debugMode = 'TRUE'
 begin
  select * from @wt
  return
 end

 exec dbo.journalEntryCRUD 0,
  @description = @jeDescription,
  @jeType = 'REFUND',
  @postDate = @postDate,
  @resultCode = @resultCode output,
  @newId = @newId output

 insert glDetailStage (accountId,accountCode,accountDesc,amount,slink,contraId,targetAccountId) 
 select accountId, accountCode, accountDesc, amount, 'o' + cast(@newId as varchar), contraId, targetId from @wt

--TODO: Level9 this needs to be one row per invoice on each receipt. so this means we need receiptId on journalLink
-- we need to also make sure that we have an slink2 for the AR balance on the invoices
 insert journalLink ( jeId, receiptId, methodRate )
 select @newId, @receiptId, 1

 -- post
 exec dbo.glPost @newId, 'o'

 -- update
 exec dbo.journalEntryCRUD 2, @id = @newId
*/
 
 return
end