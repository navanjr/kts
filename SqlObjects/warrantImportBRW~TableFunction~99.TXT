create function dbo.warrantImportBRW(
 @id int,
 @csvBlob varchar(max) = null,
 @bankcode varchar(60)
) returns @rt table(
 id int identity(1,1),
 fiscalYear varchar(50),
 clerksFund varchar(50),
 warrantNumber varchar(50),
 warrantDate varchar(50),
 accountNumber varchar(50),
 amount varchar(50),
 vendorCode varchar(max),
 accountBlob varchar(1000),
 debitAcct varchar(50),
 creditAcct varchar(50),
 postCheck int,
 expenseAcct varchar(50),
 registerNumber varchar(50),
 fundCode varchar(60),
 fundDesc varchar(50),
 rowType int,
 ord varchar(100),
 accountNumberBLOB varchar(max)
)
begin

 declare @wt table(
  id int identity(1,1),
  fiscalYear varchar(50),
  clerksFund varchar(50),
  warrantNumber varchar(50),
  warrantDate varchar(50),
  accountNumber varchar(50),
  amount varchar(50),
  vendorCode varchar(max),
  accountBlob varchar(1000),
  debitAcct varchar(50),
  creditAcct varchar(50),
  postCheck int,
  expenseAcct varchar(50)
 )

-- TODO: ok at some point i want to add the officials bank account to the contraid on the Debit to the _WR account this will make the bank statement work cooler!

 declare
  @idToken int,
  @logitId int,
  @dataToken nvarchar(max),
  @csv nvarchar(max),
  @debitAcct varchar(50),
  @creditAcct varchar(50),
  @officalLink int,
  @lastNumber int,
  @payee varchar(max) = '',
  @binFileName varchar(max),
  @warrantsHitLedgerWhenRegistered varchar(5) = dbo.settingsf('site.warrantsHitLedgerWhenRegistered','FALSE')


-- get the csv from the importer or from the passed variable
 if isnull(@id,0) > 0 
 begin

  select
   @officalLink = link2,
   @debitAcct = key2,
   @csv = cast(e1 as nvarchar(max)) + cast(e2 as nvarchar(max)),
   @logitId = cast(olink5 as int)
  from object where typ = 4770 and id = @id

  if left(@csv,14) = 'File too large'
   select @csv = message from keyLog where id = @logitId

 end
 else
 begin
  select
   @officalLink = null,
   @debitAcct = null,
   @csv = @csvBlob
 end

-- TODO: until im sure this is right... im gonna get the debit account from the officals exepense field :)
 select 
  @creditAcct = a4 from object where id = @officalLink and typ = 4601

 -- take the csv data and run with it
 declare @rows table(
  id int identity(1,1),
  rowData varchar(1000)
 )

-- TODO: this seems to work well. however we might have an issue with char(13)'s getting left in the data.
 insert @rows 
 select replace(data,'"','') from dbo.split( @csv, char(10))

 while exists(select * from @rows)
 begin
  select top 1
   @idToken = id,
   @dataToken = rowData
  from @rows order by id
  
  select @payee = @payee +', ' + data from dbo.split(@dataToken,',') where id > 6

  if (select data from dbo.split(@dataToken,',') where id = 4) > '  0'
   insert @wt select 
    (select data from dbo.split(@dataToken,',') where id = 1),
    (select data from dbo.split(@dataToken,',') where id = 2),
    (select data from dbo.split(@dataToken,',') where id = 3),
--    (select data from dbo.split(@dataToken,',') where id = 4),
    (select dbo.clarionDate(data) from dbo.split(@dataToken,',') where id = 4),
    (select data from dbo.split(@dataToken,',') where id = 5),
    dbo.stripNonNumeric((select data from dbo.split(@dataToken,',') where id = 6)),
    substring(@payee,3,50),
    null,null,null,null,null
  set @payee = ''
  delete @rows where id = @idToken
 end

   update @wt set accountNumber = cfl.a4 from @wt w, object cfl where cfl.typ=4704 and w.clerksFund = cfl.key2 and cfl.a16='1' and accountNumber<' 0'


-- gather up the accounts to hit
-- credit fund accrued payable
-- debit expense account per fund
   update @wt set accountBlob = dbo.glAccountGetFundAccrualBlob(clerksFund, 'Clerks Fund')
   update @wt set 
    creditAcct = case when isnull(@warrantsHitLedgerWhenRegistered,'FALSE') = 'TRUE' then 
     case when len(dbo.readString('@overrideBankCode=',accountBlob)) > 1 then dbo.readString('@overrideBankCode=',accountBlob) else @bankcode end
    else  dbo.readString('@accrualCode=',accountBlob) end,
    debitAcct = case when isnull(@warrantsHitLedgerWhenRegistered,'FALSE') = 'TRUE' then dbo.readString('@fundCode=',accountBlob) else dbo.readString('@warrantRegisterCode=',accountBlob) end,
    expenseAcct = case when isnull(@warrantsHitLedgerWhenRegistered,'FALSE') = 'TRUE' then '' else dbo.readString('@expenseCode=',accountBlob) end


 insert @rt 
  select
   fiscalYear,
   clerksFund,
   dbo.popro6(warrantNumber,6,0),
   warrantDate,
   case when count(accountnumber)>1 then 'MULT' else max(accountNumber) end,
   cast(sum(cast(amount as money)) as varchar(50)),
   vendorCode,
   accountBlob,
   debitAcct,
   creditAcct,
   0,
   expenseAcct,
   0,
   '',
   '',
   0,
   'b',
   replace(isnull(stuff((select '|'+accountNumber+':'+cast(amount as varchar) from @wt w1 where w.fiscalyear=w1.fiscalyear and w1.accountnumber > ' 0' and w.clerksfund=w1.clerksfund and w.warrantNumber=w1.warrantNumber FOR XML PATH('')),1,1,''),''),'&amp;','&')
  from @wt w
  group by
   fiscalYear,
   clerksFund,
   warrantNumber,
   warrantDate,
--   accountnumber,
   vendorCode,
   accountBlob,
   debitAcct,
   creditAcct,
   postCheck,
   expenseAcct

 update @rt set fiscalyear = cast(cast('20'+right(fiscalyear,2) as int)-1 as varchar(4))+'-'+'20'+right(fiscalyear,2) where fiscalyear > ' 0' and isnumeric(right(fiscalyear,2))=1

 update @rt set postCheck = 1 where debitAcct not in (select accountCode from glAccounts)
 update @rt set postCheck = 1 where creditAcct not in (select accountCode from glAccounts)
 update @rt set postCheck = 1 where isnull(vendorCode,'')=''

 update r set postcheck = 2, registerNumber=w.RegNo from @rt r, warrants w where r.postcheck = 0 and r.warrantNumber=w.WarNo and w.debitcode=r.debitAcct and w.fiscalYear=r.fiscalYear

 update r set fundCode = f.accountCode, fundDesc = f.accountDesc from @rt r, glaccounts a, glaccounts f where r.debitacct = a.accountCode and f.accountCode = a.targetAccountCode
  
-- set the potential register numbers
 select top 1 @lastNumber = cast(key1 as int) from object where typ = 4771 and a18 = 'Warrant' order by key2 desc, key1 desc
 declare @reg table(regSeed int identity(1,1), id int)
 insert @reg select id from @rt where postCheck = 0 order by clerksFund,warrantNumber
 update a set registerNumber = dbo.padLeft(@lastNumber + b.regSeed,'0',5) from @rt a, @reg b where a.id = b.id

-- lets add a total of amount to the top of the BRW
 insert @rt (rowType, amount, vendorCode, ord)
 select
  -1,
  sum(cast(amount as money)),
  cast(count(*) as varchar) + ' warrant(s)', 'a' from @rt where postCheck = 0-- registerNumber > '0'

 return 
end