create proc dbo.apiInvoices(
 @taxyear varchar(4) = null,
 @method varchar(50) = 'GET',
 @batchSize int = null,
 @postFile varchar(50) = 'apiPostInvoices.json',
 @scratchFile varchar(1000) = null,
 @debugMode varchar(5) = 'FALSE',
 @result varchar(max) = null output,
 @dropRawFile varchar(5) = 'FALSE',
 @includeRecall varchar(5) = 'TRUE'
) as
begin
 set nocount on

 declare
  @resource varchar(50) = 'invoices',
  @apiService varchar(50),
  @tempPath varchar(50), 
  @postFileFull varchar(100), 
  @apiCode varchar(50),
  @apiwt JSONHierarchy,
  @filter varchar(500),
  @apiResource varchar(50) = '/v2/treasurer/invoices',
  @dump varchar(max),
  @log varchar(max),
  @tokenId int,
  @apiResultWt JSONHierarchy,
  @theDate datetime,
  @updated int,
  @inserted int,
  @tally int,
  @goofyChars varchar(100) = '13,10,9,167,248,34,39,129'

 exec dbo.keyAcVars 'acapiservice', @silentMode = 'TRUE', @dump = @apiService output
 exec dbo.logit @@procid, '@method', @method, '@batchSize', @batchSize, '@apiService', @apiService, @override = 'TRUE'

-- if not @apiService = 'ON' 
--  return

 select @tempPath = path from dbo.paths() where name = 'temp'
 select top 1 @apiCode = b12 from object where typ = 40 order by id
 set @postFileFull = @tempPath + '\' + @postFile
 if @scratchFile is null
  set @scratchFile = @tempPath + '\' + 'apiResultInvoices.tmp'

 declare @jsonPrep table(
  id int identity(1,1),
  parentId int,
  objectId int,
  name varchar(50),
  value varchar(500),
  type varchar(50)
 )

 declare @wt table(
  parentId int identity(1,1),
  invoice_link int,
  invoice_parent_link int,
  tax_roll_link int,
  tax_Year varchar(4),
  invoice_due money,
  invoice_amount money,
  posted_date varchar(50),
  interest_date varchar(50),
  item_number varchar(50),
  invoice_type varchar(1),
  name varchar(50),
  parcel varchar(50),
  adtaxtotaldue money
 )

 declare @taxyears table(year varchar(4))
 if not @taxyear is null 
  insert @taxyears select @taxYear
 else
  insert @taxyears select taxyear from invoices group by taxyear

 if @method = 'JOB'
 begin
  select @batchSize = coalesce(@batchSize, batchSize) from dbo.apiControlBRW() where resource = @resource
  exec dbo.apiInvoices @method = 'POST', @batchSize = @batchSize
  exec dbo.apiRecall_invoices
 end

 if @method = 'STATUS'
 begin
  declare @taxyearToken varchar(4)
  declare @status table(taxyear varchar(4), total int, stale int, percentStale money)

  if not @taxyear = 'ALL'
   insert @status select taxYear, count(*), sum(case when isnull(apiUpdated,0) < modified then 1 else 0 end), null
    from invoices where taxyear in (select year from @taxyears) group by taxyear
  else
   insert @status select 'ALL', count(*), sum(case when isnull(apiUpdated,0) < modified then 1 else 0 end), null
    from invoices where taxyear in (select year from @taxyears)

  update @status set percentStale = (cast(stale as money)/cast(total as money)) * 100.0

   while exists(select * from @taxyears)
   begin
    select top 1 @taxYearToken = year from @taxyears order by year
    select @log = '@taxyear=' + taxyear + ';' 
     + '@total=' + cast(total as varchar) + ';'
     + '@stale=' + cast(stale as varchar) + ';'
     + '@%stale=' + cast(percentStale as varchar) + '%;'
    from @status where taxyear = @taxyearToken
    exec dbo.logit @@procid, @log, @override = 'TRUE'
    delete @taxyears where year = @taxyearToken
   end

  return
 end

 
 if @method = 'POST'
 begin

-- deleted invoices
  declare
   @deletedBatchSize int = 20,
   @deletedInvoiceStringBlob stringBlob

  if @batchsize < @deletedBatchSize
   set @deletedBatchSize = @batchSize

  insert @deletedInvoiceStringBlob
  select top (@deletedBatchSize) cast(dbo.slinkId(slink) as varchar) + '|' + cast(invoice_link as varchar) from dbo.apiInvoiceIds() where typ = 'deletedInvoice'
  if exists(select * from @deletedInvoiceStringBlob)
  begin
   declare 
    @apiDeletedFields blobFields,
    @payload varchar(max),
    @deletedTally int
	 
	 declare @deletedInvoiceQueue table(slink varchar(50))
   
	 insert @deletedInvoiceQueue select 't' + dbo.splitF(blob,'|',1) from @deletedInvoiceStringBlob
		 
-- reset the batch size for use in the final comparison
   select @deletedBatchSize = count(*) from @deletedInvoiceStringBlob

   insert @apiDeletedFields select 'invoice_link','int',0
   exec dbo.pipedStringToJson @deletedInvoiceStringBlob, @apiDeletedFields, @urlEncode = 'TRUE', @payload = @payload output

   exec spOverwriteTextFile @postFileFull, @payload
   exec dbo.logit @@procid, '@deletedBatchSize', @deletedBatchSize
   exec dbo.api
    @method = 'DELETE',
    @resource = @apiResource,
    @postFile = @postFile,
    @debugMode = @debugMode,
    @scratchfile = @scratchFile,
    @cmdOutput = @tokenId output,
    @dump = @dump output

   select @deletedTally = dbo.apiResultDecoder('deleted', @dump) 
   if isnull(@deletedTally,0) = @deletedBatchSize
   begin
    set @theDate = getDate()
	  update apiDeleted set apiUpdated = @theDate
	    where apiResource = 'invoices' 
	      and isnull(apiUpdated,0) < modified
	      and slink in (select slink from @deletedInvoiceQueue)
				--(select 't' + dbo.splitF(blob,'|',1) from @deletedInvoiceStringBlob)
				-- REMOVED BY Nate: using this splitF() this way made this update very slow.
    exec dbo.logit @@procid, 'Success...', @dump,'updated apiDeleted rows... @@rowcount', @@rowCount, @override = 'TRUE'
   end
   else
   begin
    exec dbo.logit @@procid, 'Failure...', @dump, @override = 'TRUE'
   end

  end
  else
  begin
   exec dbo.logit @@procid, 'all deleted invoice records updated... nothing to do. :)', @override = 'TRUE'
  end

-- invoices
  declare @ids ids
  insert @ids select dbo.slinkId(slink) from dbo.apiInvoiceIds() where typ = 'invoice'

-- create the post data file then call the API
  insert @wt select top (@batchSize)
   i.id, 
   i.invoiceId,
   i.taxrollId,
   i.taxyear,
   i.invoiceDue,
   i.invoiceAmount,
   dbo.date112(i.postdate),
   case when i.interestDate = 0 then '' else dbo.date112(i.interestDate) end,
   i.item,
   i.typ, 
   dbo.stripChars(i.name,@goofyChars), 
   dbo.stripChars(i.parcel,@goofyChars),
   a.totaldue as adtaxtotaldue
  from invoices i
  left join adtax a on a.id = i.taxrollid and i.typ <> 'S'
  where i.id in (select id from @ids)
  order by i.id  

  update @wt 
  set invoice_amount = cast(dbo.taxCorrectionsSF(adtaxtotaldue,tax_roll_link,'078') as money)
  where adtaxtotaldue <> invoice_amount and invoice_amount <> 0.00 and invoice_type <> 'S' and isnull(adtaxtotaldue,0) <> 0

-- bail if your done or update batchSize from tally, maybe... 
  select @tally = count(*) from @wt
  if isnull(@tally,0) = 0
  begin
   exec dbo.logit @@procid, 'all records updated... nothing to do. :)', @override = 'TRUE'
   return
  end
 
  if @batchSize != @tally
  begin
   set @batchSize = @tally
   exec dbo.logit @@procid, 'ATTENTION... Changed... @batchSize', @batchSize, @override = 'TRUE'
  end

  insert @jsonPrep select parentId,null,'site_id',@apiCode,'int' from @wt
  insert @jsonPrep select parentId,null,'owner',name,'string' from @wt
  insert @jsonPrep select parentId,null,'parcel',parcel,'string' from @wt
  insert @jsonPrep select parentId,null,'invoice_link',invoice_link,'int' from @wt
  insert @jsonPrep select parentId,null,'invoice_parent_link',invoice_parent_link,'int' from @wt
  insert @jsonPrep select parentId,null,'tax_roll_link',tax_roll_link,'int' from @wt
  insert @jsonPrep select parentId,null,'tax_year',tax_year,'int' from @wt

  insert @jsonPrep select parentId,null,'item_number',item_number,'int' from @wt
  insert @jsonPrep select parentId,null,'invoice_type',invoice_type,'string' from @wt

  insert @jsonPrep select parentId,null,'invoice_due',invoice_due,'int' from @wt
  insert @jsonPrep select parentId,null,'invoice_amount',invoice_amount,'int' from @wt

  insert @jsonPrep select parentId,null,'posted_date',case when posted_date = '' then '""' else posted_date end,'int' from @wt 
  insert @jsonPrep select parentId,null,'interest_date',case when interest_date = '' then '""' when interest_date = 0 then '""' else interest_date end,'int' from @wt

-- insert lowest level object wrapper
  select @tokenId = MAX(id) + 1 from @jsonPrep
  insert @jsonPrep (objectId,parentId,name,value,type) 
  select parentId,@tokenId,null,'','object' from @jsonPrep group by parentId
-- insert array wrapper
  insert @jsonPrep (objectId,name,value,type) 
  select @tokenId,'','','array'

  insert @apiwt select * from @jsonPrep
  select @dump = 'site_id='+@apiCode+'&rows='+dbo.URLEncode(dbo.toJSON(@apiwt))

  exec spOverwriteTextFile @postFileFull, @dump
  
  exec dbo.api
   @method = @method,
   @resource = @apiResource,
   @postFile = @postFile,
   @debugMode = @debugMode,
   @scratchfile = @scratchFile,
   @cmdOutput = @tokenId output,
   @dump = @dump output

  set @result = @dump 

  insert @apiResultWt select * from dbo.parseJSON(@dump)
  select @updated = cast(stringValue as int) from @apiResultWt where name = 'updated' and valueType = 'int'
  select @inserted = cast(stringValue as int) from @apiResultWt where name = 'created' and valueType = 'int'
  if isnull(@updated,0) + isnull(@inserted,0) =  @batchSize
  begin
   set @theDate = getDate()
   update invoices set apiUpdated = @theDate where id in (select invoice_link from @wt)
   exec dbo.logit @@procid, 'Success...', @dump, @override = 'TRUE'
  end
  else
  begin
   exec dbo.logit @@procid, 'Failure...', @dump, @override = 'TRUE'
  end

  return
 end

end