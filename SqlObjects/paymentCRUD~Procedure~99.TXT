create proc dbo.paymentCRUD(
 @mode int,
 @paymentType varchar(50) = null,
 @officialName varchar(50) = '',
 @officialDepositCode varchar(50) = '',
 @officialBankCode varchar(50) = '',
 @voucherDate int = 0,
 @voucherNumber varchar(50) = '',
 @payee varchar(50) = '',
 @amount money = 0,
 @debitAcct varchar(50) = '',
 @creditAcct varchar(50) = '',
 @id int = 0,
 @bankStatementId int = 0,
 @postResult varchar(100) = null output,
 @postOverride varchar(5) = 'FALSE',
 @deleteObject varchar(5) = 'FALSE',
 @fiscalYear varchar(50) = '',
 @importStamp varchar(50) = '',
 @comments varchar(250) = '',
 @voidBatch varchar(5) = 'FALSE',
 @statusInput varchar(50) = null,
 @nextNumAdditionalWhere varchar(500) = '',
 @clobberKey1 varchar(50) = null,
 @verbose varchar(5) = 'TRUE',
 @skipSQLTransactionOnGlPost varchar(5) = 'FALSE',
 @accountNumberBLOB varchar(max) = '',
 @reasonToCancel varchar(50) = ''
) as 
begin
 set nocount on

-- TODO: i have an idea for the parking lot.
/*
  create a mode 4 = this is a mode that returns the delete message for the user.  this would standardize all our CRUD routines from key
  started mode 4, so far it just provides labels for the change window
*/

 declare @newIdWt newIdWt
 
 declare
  @slink varchar(15) = 'o' + cast(@id as varchar),
  @postedStatus varchar(50),
  @log varchar(max),
  @postDate int,
  @newId int,
  @warrantPayee varchar(50) = ''

 select @postedStatus = status from dbo.glStatus(@slink)

 if @mode = 6 and isnull(@statusInput,'') in ('saved','abandoned')
 begin
  exec dbo.logit @@procId, '@mode', @mode, '@id', @id, '@statusInput', @statusInput, '@postedStatus', @postedStatus
  if not @postedStatus = 'missing'
  begin
   exec dbo.logit @@procId, 'bailing because @postedStatus is not MISSING'
   return
  end

  if @statusInput = 'saved'
   update object set a17 = 'Saved' where typ = 4771 and id = @id
  if @statusInput = 'abandoned'
   update object set a17 = 'Abandoned', typ = -4771 where typ = 4771 and id = @id
  return
 end


 if @mode = 4
 begin
  exec dbo.logit @@procId, '@mode', @mode, '@paymentType', @paymentType

   select @log = case when @paymentType in ('Official Voucher','Trust Voucher','Protest Voucher') then 
    '@debitFieldLabel=Deposit Account;'
    + '@creditFieldLabel=Bank Account;'
    + '@key1FieldLabel=Register #;'
    + '@key2FieldLabel=Register Date;'
    + '@key3FieldLabel=Voucher #;'
    + '@a1FieldLabel=Voucher Date;'

  when  @paymentType = 'Warrant'
   then 
    '@debitFieldLabel=WR Fund;'
    + '@creditFieldLabel=ACP Fund;'
    + '@key1FieldLabel=Register #;'
    + '@key2FieldLabel=Register Date;'
    + '@key3FieldLabel=Warrant #;'
    + '@a1FieldLabel=Warrant Date;'

  when right(@paymentType,5) = 'Check'
   then
    '@debitFieldLabel=ACP Fund;'
    + '@creditFieldLabel=EXP Fund;'
    + '@key1FieldLabel=Control #;'
    + '@key2FieldLabel=Date Created;'
    + '@key3FieldLabel=Treasurers #;'
    + '@a1FieldLabel=Check Date;'

  when @paymentType = 'Miscellaneous'
   then
    '@debitFieldLabel=Fund Account;'
    + '@creditFieldLabel=Bank Account;'
    + '@key1FieldLabel=Payment #;'
    + '@key2FieldLabel=Date Created;'
    + '@key3FieldLabel=Hidden Key3;'
    + '@a1FieldLabel=Hidden A1;'

  when @paymentType = 'TRANSFER'
   then
    '@debitFieldLabel=To Bank Acct;'
    + '@creditFieldLabel=From Bank Acct;'
    + '@key1FieldLabel=Voucher #;'
    + '@key2FieldLabel=Date Created;'
    + '@key3FieldLabel=Hidden Key3;'
    + '@a1FieldLabel=Hidden A1;'

   else
    '@debitFieldLabel=Deposit Account;'
    + '@creditFieldLabel=Bank Account;'
    + '@key1FieldLabel=Treasurer #;'
    + '@key2FieldLabel=Treasurer Date;'
    + '@key3FieldLabel=Voucher #;'
    + '@a1FieldLabel=Voucher Date;'

   end

  if @verbose = 'TRUE'
   select @log

 end

 if @mode = 3
 begin
  exec dbo.logit @@procid, 'start mode 3 - @paymentType', @paymentType, '@postOverride', @postOverride, '@voidBatch', @voidBatch

  if @paymentType = 'VOIDMAINTENANCE'
  begin
  -- this routine exists to remove potential orphans
   if exists(
    select * from gldetail 
     where left(slink,1) = 'o'
      and slink not in (select 'o'+cast(id as varchar) from object where TYP > 0) 
   )
   begin
    exec dbo.logit @@procid, 'you got a problem, orphaned glDetail.  Let me get that for you...'
    begin transaction
     delete gldetail where left(slink,1) = 'o' and slink not in (select 'o'+cast(id as varchar) from object where TYP > 0) 
    commit transaction
    exec dbo.logit @@procid, 'No worries i got it...'
   end
   return
  end

  -- bail if we are already posted
  if dbo.isPosted(@slink) = 'TRUE' and @postOverride != 'TRUE'
   return 

  -- bail if id is not greater than 0
  if @id < 1
   return

-- if you want to roll back an entire import batch we just delete everything and cleanup object.
  if @voidBatch = 'TRUE'
  begin
   select @importStamp = a16 from object where typ = 4771 and id = @id
   declare @toRemove table(id int, slink varchar(15))
   insert @toRemove select id, 'o' + cast(id as varchar) from object where typ = 4771 and a16 = @importStamp
   exec dbo.logit @@procid, 'Begin transaction...'
   begin transaction
    delete dbo.glDetailStage where slink in (select slink from @toRemove)
    delete dbo.glDetail where slink in (select slink from @toRemove)
    update object set typ = -4771 where typ = 4771 and id in (select id from @toRemove)
    update object set link1 = 0 where typ = 4771 and link1 in (select id from @toRemove)
   commit transaction
   exec dbo.logit @@procid, 'Commited transaction.'
   return
  end

  if (select a17 from object where id = @id) = '' and not exists(select * from glDetail where slink = @slink)
   set @deleteObject = 'TRUE'

  begin transaction
  delete dbo.glDetailStage where slink = @slink
  delete dbo.glDetail where slink = @slink
  if @deleteObject = 'TRUE'
   update object set typ = -4771 where id = @id
  else
   update object set
    a3 = '',
    a17 = 'VOID' 
   where id = @id
  update object set link1 = 0 where typ = 4771 and link1 = @id
  commit transaction

  return

 end

 if @mode = 0
 begin

  exec dbo.logit @@procid, 'start mode 0 - paymentType', @paymentType, 'paymentId @id', @id

-- TODO: add gl check here

  declare
   @nextVoucherNumber varchar(50) = '',
   @whoami varchar(max) = dbo.whoami(),
   @myIni varchar(50),
   @myStation varchar(50)
 
  select 
   @myIni = dbo.readstring('@ini=',@whoami),
   @myStation = dbo.readstring('@station=',@whoami)
 
 -- Issued from Trust or Protest Receipt will finish posting from the voucher edit screen after entering additional info needed for trust receipts
  if @paymentType = 'Trust Voucher'
  begin
   select
    @voucherDate = dbo.clarionDate(getDate()),
    @debitAcct = key3,
    @creditAcct = key2
   from object where typ = 4503 and key1 = 'TRUST'

   select top 1 @debitAcct = key3 from object where typ=4503 and key1='TRUST'
  end

  if @paymentType = 'Protest Voucher'
  begin
   set @voucherDate = (select dbo.clarionDate(getDate()))
   select top 1 @creditAcct = key2 from object where typ=4503 and key1='TAX'
  end

  if @paymentType = 'Buy Warrant'
  begin
-- bail if we are already bought...
   if (select warrantLinkId from dbo.payments where id = @id) != 0
   begin
    exec dbo.logit @@procid, 'sorry already bought... nice try :)'
    return
   end
-- if you are buying a warrant with a treasurers check, payment type needs to change, among other things
-- Notice the DB and CR accounts are swapped.
   select
    @paymentType = 'Treasurers Check',
    @voucherDate = case when @voucherDate > 0 then @voucherDate else dbo.clarionDate(getDate()) end,
    @amount = a.a3,
    @debitAcct = a.a5,
    @creditAcct = a.a4,
    @officialName = a.a7,
    @officialDepositCode = b.targetAccountCode,
    @officialBankCode = a.a9,
    @fiscalYear = c10,
    @nextNumAdditionalWhere = 'a8 = ''' + rtrim(b.targetAccountCode) + ''' and c10=''' + rtrim(c10) + '''',
    @warrantPayee = a.a2
   from object a, glAccounts b where a.typ = 4771 and a.id = @id and b.accountCode=a.a5

   if @bankStatementId > 0
    select @officialBankCode = key1 from object where typ = 4780 and id = @bankStatementId

   select @payee = accountDesc from dbo.glAccounts where accountCode = @officialBankCode

  end

  if left(@paymentType,7) = 'Cancel ' or left(@paymentType,5) = 'Void '
  begin
   select
    @voucherDate = case when @voucherDate > 0 then @voucherDate else dbo.clarionDate(getDate()) end,
    @voucherNumber = a.key3,
    @payee = a.a2,
    @amount = cast(a.a3 as money) * -1,
    @debitAcct = a.a4,
    @creditAcct = a.a5,
    @officialName = a.a7,
    @officialDepositCode = a.a8,
    @officialBankCode = a.a9
   from object a where a.typ = 4771 and a.id = @id
  end

  if @paymentType not in ('Miscellaneous','Transfer')
   exec dbo.nextObjectAutoNumber
    4771,
    @paymentType,
    @ignoreDeleted = 'TRUE',
    @additionalWhereClause = @nextNumAdditionalWhere,
    @clobber = @clobberKey1,
    @newNumber = @nextVoucherNumber output


-- bail if we don't have all the accounts we need...
  if (@debitAcct < '  0' or @creditAcct < '  0' or @officialBankCode < '  0' or @officialDepositCode < '  0') and @paymentType not in ('MISCELLANEOUS','Transfer','Trust Voucher','Warrant','Cancel MISCELLANEOUS')
  begin
   exec dbo.logit @@procid,
    'Oops, Missing one of the following...  @debitAcct', @debitAcct,
    '@creditAcct', @creditAcct,
    '@officialBankCode', @officialBankCode,
    '@officialDepositCode', @officialDepositCode

    if @verbose = 'TRUE'
     select '@code=1;@message=Missing Account details. Contact Support (paymentCRUD:BuyWarrant1);'

   return
  end

-- bail if we don't have all the accounts we need for a warrant...
  if (@debitAcct < '  0' or @creditAcct < '  0' or @officialBankCode < '  0') and @paymentType in ('Warrant')
  begin
   exec dbo.logit @@procid,
    'Oops, Missing one of the following...  @debitAcct', @debitAcct,
    '@creditAcct', @creditAcct,
    '@officialBankCode', @officialBankCode
 
    if @verbose = 'TRUE'
     select '@code=1;@message=Missing Account details. Contact Support (paymentCRUD:RegisterWarrant2);'
 
   return
  end

-- bail if we don't have all the accounts we need for a Trust Voucher...
  if (@debitAcct < '  0' or @creditAcct < '  0') and @paymentType in ('Trust Voucher')
  begin
   exec dbo.logit @@procid,
    'Oops, Missing one of the following...  @debitAcct', @debitAcct,
    '@creditAcct', @creditAcct,
    '@officialBankCode', @officialBankCode,
    '@officialDepositCode', @officialDepositCode
 
   if @verbose = 'TRUE'
    select '@code=1;@message=Missing Account details. Contact Support (paymentCRUD:BuyWarrant3);'
 
   return
  end

  declare @registerDateOverride varchar(20) = 'FALSE'

  if @paymentType = 'official Voucher'
   set @registerDateOverride = dbo.settingsF('site.voucherPostDateEqualsVoucherDate','FALSE')

  set @postDate = case when @registerDateOverride = 'TRUE' and isnull(@voucherDate,'') > ' 0' then isnull(@voucherDate,'') else dbo.clarionDate(getDate()) end

  exec dbo.logit @@procid, '@nextVoucherNumber=',@nextVoucherNumber, '@paymentType', @paymentType, '@postDate', @postDate

  exec dbo.logit @@procid, 'begin SQL Transaction...'
 begin transaction
 begin try
  insert object 
  (
   typ,
   key1, key2, Key3, a1,
   a2, a3, a4, b3, a5, b4, a18,
   a7, a8, a9, c10, a16, e1, c5, a12, a13, a14
  )
  output inserted.id into @newIdWt
  select 
   4771,
   @nextVoucherNumber,
   coalesce(nullif(@postDate,''),dbo.clarionDate(getdate())),
   @voucherNumber,
   isnull(@voucherDate,''), -- needs isnull because we use a datatype of int inside our procs, therefore we cant default to ''
   @payee,
   @amount,
   @debitAcct,isnull((select accountDesc from glAccounts where accountCode=@debitAcct),''),
   @creditAcct,isnull((select accountDesc from glAccounts where accountCode=@creditAcct),''),
   dbo.proper(@paymentType),
   @officialName,
   isnull(@officialDepositCode,''),
   isnull(@officialBankCode,''),
   @fiscalYear,
   @importStamp,
   @comments,
   @warrantPayee,
   @myIni,
   @myStation,
   @reasonToCancel
 end try
 begin catch
  set @log = error_message()
  exec dbo.logit @@procid, 'sqlCatchError', @log
 end catch

  select @newId = max(id) from @newIdWt
  declare @newslink varchar(15) = 'o' + cast(@newId as varchar)
  exec dbo.logit @@procid, '@newId', @newId, '@newslink', @newslink

 end

 if @mode=0 and @paymentType in ('Trust Voucher','Protest Voucher','MISCELLANEOUS','Transfer')
 begin
  commit transaction    
  exec dbo.logit @@procid, 'commit SQL Transaction! and quickly return - 1'

  if @verbose = 'TRUE'
   select '@code=0;@message=Payment Created;@id='+cast(@newId as varchar)

  return
 end

 declare @stageRows table(acctCode varchar(50), amount money, glType varchar(50))

 if @mode = 0 and @paymentType not in ('Trust Voucher','Protest Voucher','MISCELLANEOUS','Transfer')
 begin

  insert @stageRows 
    select @debitAcct, @amount, 'debitAcct'
   union all
    select @creditAcct, @amount * -1, 'creditAcct'

  if @paymentType in ('Treasurers Check') and @bankStatementId > 0 
  begin

-- add the extra side of this transaction we need for buying warrants
   insert @stageRows 
     select @officialDepositCode, @amount, 'officialDepositCode'
    union all
     select @officialBankCode, @amount * -1, 'officialBankCode'

-- and mark the original warrant as bought!
   update object set 
    a19 = @nextVoucherNumber,
    link1 = @newId
   where typ = 4771 and id = @id

  end

  if @paymentType in ('Cancel Voucher','Cancel Warrant','Cancel Miscellaneous')
  begin

-- and mark the original warrant as bought!
   update object set 
    a14 = @reasonToCancel,
    a19 = @nextVoucherNumber,
    link1 = @newId
   where typ = 4771 and id = @id

  end
  
  if @paymentType='Warrant'
  begin


    declare @trackAppropriationLedger varchar(20),
            @targetFundCodeToken varchar(50)

     select @trackAppropriationLedger=settingValue from settings where settingName='site.trackAppropriationLedger'

     select @targetFundCodeToken = rtrim(targetAccountCode) from glaccounts where accountCode = @debitAcct

  
    if @trackAppropriationLedger='TRUE'
    begin
     if @accountNumberBLOB > ' 0' and @fiscalYear > ' 0' and @targetFundCodeToken > ' 0'
     begin
      declare @budgetAccounts table(id int identity(1,1),
                                  accountNumber varchar(50),
                                  budgetAccountCode varchar(50),
                                  budgetFundCode varchar(50),
                                  amount money,
                                  processCode int
                                  )
      insert @budgetAccounts (accountNumber,amount,processCode)
       select rtrim(dbo.splitf(data,':',1)),cast(dbo.splitf(data,':',2) as money),0 from dbo.split(@accountNumberBLOB,'|')
    
      declare @budgetIdToken int,
            @budgetAccountNumberToken varchar(50),
            @budgetAccountCodeToken varchar(50),
            @budgetFundCodeToken varchar(50)
      
      
      while exists(select * from @budgetAccounts where processCode = 0)
      begin
       select top 1 @budgetIdToken = id, @budgetAccountNumberToken = accountNumber from @budgetAccounts where processCode = 0
     
       exec dbo.budgetAccountVerification
            @budgetAccountNumberToken, 
            @fiscalYear, 
            @targetFundCodeToken, 
            @budgetAccountCode = @budgetAccountCodeToken output,
            @budgetFundCode = @budgetFundCodeToken output
     
       update @budgetAccounts 
        set budgetAccountCode = @budgetAccountCodeToken,
          budgetFundCode = @budgetFundCodeToken,
          processCode = 1
        where id = @budgetIdToken

      end

     insert @stageRows 
       select budgetAccountCode, sum(amount), 'budgetAccountCode' from @budgetAccounts group by budgetAccountCode
      union all
       select budgetFundCode, sum(amount) * -1, 'budgetFundCode' from @budgetAccounts group by budgetFundCode



     end
    end
  end


  declare @checkStyleWarrants varchar(20) = 'FALSE'

  select @log = cast(count(*) as varchar) from @stageRows
  exec dbo.logit @@procid, '@stageRows record count', @log

  set @log = '@stageRows Table' + char(13) + char(10) + dbo.padRight('acctCode',' ',15) + dbo.padLeft('amount',' ',15) + ' ' + 'glType' + char(13) + char(10)
  select @log = @log + dbo.padRight(acctCode,' ',15) + dbo.padLeft(cast(amount as varchar),' ',15) + glType + char(13) + char(10) from @stageRows
  exec dbo.logit @@procid, @log

  insert dbo.glDetailStage (accountId, accountCode, accountDesc,date,amount,slink,slink2)
  select b.accountId, b.accountCode, b.accountDesc, @voucherDate, a.amount, @newslink, case when isnull(@id,0)>0 then 'o' + cast(@id as varchar) else null end
   from @stageRows a, glAccounts b 
   where a.acctCode = b.accountCode

  commit transaction    
  exec dbo.logit @@procid, 'commit SQL Transaction! and fire glPost - 2; @skipSQLTransaction', @skipSQLTransactionOnGlPost

  -- post gl
  exec dbo.glPost @newId, 'o', @verbose = 'FALSE', @skipSQLTransaction = @skipSQLTransactionOnGlPost, @resultString = @postResult output
  exec dbo.logit @@procid, 'glPost - @postResult', @postResult, '@paymentType', @paymentType, '@nextVoucherNumber', @nextVoucherNumber

  if @paymentType = 'Treasurers Check' and dbo.settingsF('site.checkStyleWarrants', 'FALSE') = 'TRUE'
    update gldetail set
     bsId = @bankStatementId,
     dateCleared=coalesce(nullif(@postDate,''),
     dbo.clarionDate(getdate())) 
    where slink = @newslink and accountcode=@officialbankcode

  if @paymentType = 'Treasurers Check' and dbo.settingsF('site.displayPaymentNumber', 'TRUE') = 'TRUE'
  begin
   exec dbo.logit @@procid, 'this is a test'
   select '@code=2;@message=Created Treasurers Check with Payment #: ' + @nextVoucherNumber + ';@caption=Buying Warrants...;'
  end
  return
 end

 if @mode = 2 and @paymentType in ('MISCELLANEOUS','Transfer')
 begin

  insert @stageRows 
    select @debitAcct, @amount, 'debitAcct'
   union all
    select @creditAcct, @amount * -1, 'creditAcct'

 
  select @log = cast(count(*) as varchar) from @stageRows
  exec dbo.logit @@procid, '@stageRows record count', @log

  set @log = '@stageRows Table' + char(13) + char(10) + dbo.padRight('acctCode',' ',15) + dbo.padLeft('amount',' ',15) + ' ' + 'glType' + char(13) + char(10)
  select @log = @log + dbo.padRight(acctCode,' ',15) + dbo.padLeft(cast(amount as varchar),' ',15) + glType + char(13) + char(10) from @stageRows
  exec dbo.logit @@procid, @log
  
  delete from glDetailStage where slink=@slink
  
  insert dbo.glDetailStage (accountId, accountCode, accountDesc,date,amount,slink)
  select b.accountId, b.accountCode, b.accountDesc, @voucherDate, a.amount, @slink
   from @stageRows a, glAccounts b 
   where a.acctCode = b.accountCode

  exec dbo.logit @@procid, 'commit SQL Transaction! and fire glPost - 2; @skipSQLTransaction', @skipSQLTransactionOnGlPost

  -- post gl
  exec dbo.glPost @id, 'o', @verbose = @verbose, @skipSQLTransaction = @skipSQLTransactionOnGlPost, @resultString = @postResult output
  exec dbo.logit @@procid, 'glPost - @postResult', @postResult

 end


 return
end
