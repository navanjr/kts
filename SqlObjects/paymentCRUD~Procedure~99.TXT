create proc dbo.paymentCRUD(
 @mode int,
 @paymentType varchar(50),
 @officialName varchar(50) = '',
 @officialDepositCode varchar(50) = '',
 @officialBankCode varchar(50) = '',
 @voucherDate int = 0,
 @voucherNumber varchar(50) = '',
 @payee varchar(50) = '',
 @amount money = 0,
 @debitAcct varchar(50) = '',
 @creditAcct varchar(50) = '',
 @id int = 0,
 @bankStatementId int = 0,
 @postResult varchar(100) = null output,
 @postOverride varchar(5) = 'FALSE',
 @deleteObject varchar(5) = 'FALSE'
) as 
begin

-- TODO: i have an idea for the parking lot.
/*
  create a mode 4 = this is a mode that returns the delete message for the user.  this would standardize all our CRUD routines from key
  started mode 4, so far it just provides labels for the change window
*/
 
 declare
  @slink varchar(15) = 'o' + cast(@id as varchar),
  @log varchar(max)

 if @mode = 4
 begin
   select @log = case when @paymentType in ('Official Voucher','Trust Voucher','Protest Voucher') then 
    '@debitFieldLabel=Deposit Account;'
    + '@creditFieldLabel=Bank Account;'
    + '@key1FieldLabel=Register #;'
    + '@key2FieldLabel=Register Date;'
    + '@key3FieldLabel=Voucher #;'
    + '@a1FieldLabel=Voucher Date;'

  when  @paymentType = 'Warrant'
   then 
    '@debitFieldLabel=WR Fund;'
    + '@creditFieldLabel=ACP Fund;'
    + '@key1FieldLabel=Register #;'
    + '@key2FieldLabel=Register Date;'
    + '@key3FieldLabel=Warrant #;'
    + '@a1FieldLabel=Warrant Date;'

  when right(@paymentType,5) = 'Check'
   then
    '@debitFieldLabel=ACP Fund;'
    + '@creditFieldLabel=EXP Fund;'
    + '@key1FieldLabel=Control #;'
    + '@key2FieldLabel=Date Created;'
    + '@key3FieldLabel=Treasurers #;'
    + '@a1FieldLabel=Check Date;'

   else
    '@debitFieldLabel=Deposit Account;'
    + '@creditFieldLabel=Bank Account;'
    + '@key1FieldLabel=Treasurer #;'
    + '@key2FieldLabel=Treasurer Date;'
    + '@key3FieldLabel=Voucher #;'
    + '@a1FieldLabel=Voucher Date;'

   end

  select @log
 end

 if @mode = 3
 begin
  exec dbo.logit @@procid, 'start mode 3 - @paymentType', @paymentType, '@postOverride', @postOverride

  if @paymentType = 'VOIDMAINTENANCE'
  begin
  -- this routine exists to remove potential orphans
   if exists(
    select * from gldetail 
     where left(slink,1) = 'o'
      and slink not in (select 'o'+cast(id as varchar) from object where TYP > 0) 
   )
   begin
    exec dbo.logit @@procid, 'you got a problem, orphaned glDetail.  Let me get that for you...'
    begin transaction
     delete gldetail where left(slink,1) = 'o' and slink not in (select 'o'+cast(id as varchar) from object where TYP > 0) 
    commit transaction
    exec dbo.logit @@procid, 'No worries i got it...'
   end
   return
  end

  -- bail if we are already posted
  if dbo.isPosted(@slink) = 'TRUE' and @postOverride != 'TRUE'
   return 

  -- bail if id is not greater than 0
  if @id < 1
   return

  if (select a17 from object where id = @id) = '' and not exists(select * from glDetail where slink = @slink)
   set @deleteObject = 'TRUE'

  begin transaction
  delete dbo.glDetailStage where slink = @slink
  delete dbo.glDetail where slink = @slink
  if @deleteObject = 'TRUE'
   update object set typ = -4771 where id = @id
  else
   update object set
    a3 = '',
    a17 = 'VOID' 
   where id = @id
  update object set link1 = 0 where typ = 4771 and link1 = @id
  commit transaction

  return

 end

 if @mode = 0
 begin

  exec dbo.logit @@procid, 'start mode 0 - paymentType', @paymentType
  exec dbo.logit @@procid, 'PaymentId', @id

-- TODO: add gl check here

  declare @nextVoucherNumber varchar(50)

 -- Issued from Trust or Protest Receipt will finish posting from the voucher edit screen after entering additional info needed for trust receipts
  if @paymentType = 'Trust Voucher'
  begin
   select
    @voucherDate = dbo.clarionDate(getDate()),
   -- @debitAcct = key3,
    @creditAcct = key2
   from object where typ = 4503 and key1 = 'TRUST'

   select top 1 @debitAcct = key3 from object where typ=4503 and key1='TRUST'
  end

  if @paymentType = 'Protest Voucher'
  begin
   set @voucherDate = (select dbo.clarionDate(getDate()))
   select top 1 @creditAcct = key2 from object where typ=4503 and key1='TAX'
  end

  if @paymentType = 'Buy Warrant'
  begin
-- if you are buying a warrant with a treasurers check, payment type needs to change, among other things
-- Notice the DB and CR accounts are swapped.
   select
    @paymentType = 'Treasurers Check',
    @voucherDate = case when @voucherDate > 0 then @voucherDate else dbo.clarionDate(getDate()) end,
    @amount = a.a3,
    @debitAcct = a.a5,
    @creditAcct = a.a4,
    @officialName = a.a7,
    @officialDepositCode = b.targetAccountCode,
    @officialBankCode = a.a9
   from object a, glAccounts b where a.typ = 4771 and a.id = @id and b.accountCode=a.a5

   if @bankStatementId > 0
    select @officialBankCode = key1 from object where typ = 4780 and id = @bankStatementId

   select @payee = accountDesc from dbo.glAccounts where accountCode = @officialBankCode

  end

  if @paymentType = 'Cancel Voucher'
  begin
   select
    @voucherDate = case when @voucherDate > 0 then @voucherDate else dbo.clarionDate(getDate()) end,
    @voucherNumber = a.key3,
    @payee = a.a2,
    @amount = cast(a.a3 as money) * -1,
    @debitAcct = a.a4,
    @creditAcct = a.a5,
    @officialName = a.a7,
    @officialDepositCode = a.a8,
    @officialBankCode = a.a9
   from object a where a.typ = 4771 and a.id = @id
  end

  exec dbo.nextObjectAutoNumber 4771, @paymentType, @ignoreDeleted = 'TRUE', @newNumber = @nextVoucherNumber output

-- bail if we don't have all the accounts we need...
  if @debitAcct < '  0' or @creditAcct < '  0' or @officialBankCode < '  0' or @officialDepositCode < '  0'
  begin
   exec dbo.logit @@procid,
    'Oops, Missing one of the following...  @debitAcct', @debitAcct,
    '@creditAcct', @creditAcct,
    '@officialBankCode', @officialBankCode,
    '@officialDepositCode', @officialDepositCode
    select '@code=1;@message=Missing Account details. Contact Support (paymentCRUD:BuyWarrant);'
   return
  end

  exec dbo.logit @@procid, 'begin SQL Transaction...'
 begin transaction
 begin try
  insert object (
   typ,
   key1, key2, Key3, a1,
   a2, a3, a4, b3, a5, b4, a18,
   a7, a8, a9
  )
  select 
   4771,
   @nextVoucherNumber,
   dbo.clarionDate(getDate()),
   @voucherNumber,
   isnull(@voucherDate,''), -- needs isnull because we use a datatype of int inside our procs, therefore we cant default to ''
   @payee,
   @amount,
   @debitAcct,isnull((select accountDesc from glAccounts where accountCode=@debitAcct),''),
   @creditAcct,isnull((select accountDesc from glAccounts where accountCode=@creditAcct),''),
   dbo.proper(@paymentType),
   @officialName,
   @officialDepositCode,
   @officialBankCode
 end try
 begin catch
  set @log = error_message()
  exec dbo.logit @@procid, 'sqlCatchError', @log
 end catch
 
  declare @newId int = @@identity
  declare @newslink varchar(15) = 'o' + cast(@newId as varchar)

  exec dbo.logit @@procid, '@newId', @newId

 end

 if @mode=0 and @paymentType in ('Trust Voucher','Protest Voucher')
 begin
  commit transaction    
  exec dbo.logit @@procid, 'commit SQL Transaction! and quickly return - 1'
  return
 end


 if @mode = 0 and @paymentType not in ('Trust Voucher','Protest Voucher')
 begin

  declare @stageRows table(acctCode varchar(50), amount money, glType varchar(50))
  insert @stageRows 
    select @debitAcct, @amount, 'debitAcct'
   union all
    select @creditAcct, @amount * -1, 'creditAcct'

  if @paymentType in ('Treasurers Check') and @bankStatementId > 0 
  begin

-- add the extra side of this transaction we need for buying warrants
   insert @stageRows 
     select @officialDepositCode, @amount, 'officialDepositCode'
    union all
     select @officialBankCode, @amount * -1, 'officialBankCode'

-- and mark the original warrant as bought!
   update object set 
    a19 = @nextVoucherNumber,
    link1 = @newId
   where typ = 4771 and id = @id

  end
 
  select @log = cast(count(*) as varchar) from @stageRows
  exec dbo.logit @@procid, '@stageRows record count', @log

  set @log = '@stageRows Table' + char(13) + char(10) + dbo.padRight('acctCode',' ',15) + dbo.padLeft('amount',' ',15) + ' ' + 'glType' + char(13) + char(10)
  select @log = @log + dbo.padRight(acctCode,' ',15) + dbo.padLeft(cast(amount as varchar),' ',15) + glType + char(13) + char(10) from @stageRows
  exec dbo.logit @@procid, @log

  insert dbo.glDetailStage (accountId, accountCode, accountDesc,date,amount,slink)
  select b.accountId, b.accountCode, b.accountDesc, @voucherDate, a.amount, @newslink
   from @stageRows a, glAccounts b 
   where a.acctCode = b.accountCode

  commit transaction    
  exec dbo.logit @@procid, 'commit SQL Transaction! and fire glPost - 2'

  -- post gl
  exec dbo.glPost @newId, 'o', @resultString = @postResult output
  exec dbo.logit @@procid, 'glPost - @postResult', @postResult

 end

 return
end