create procedure dbo.paymentsImportBatch(
 @paymentType varchar(50),
 @batchId int,
 @ini varchar(50),
 @debugMode varchar(10) = 'false' 
) as 
begin
 set nocount on
 exec dbo.logit @@procid, '@paymentType', @paymentType, '@batchId', @batchId, '@ini', @ini, '@debugMode', @debugMode

  declare
   @idToken int,
   @voucherDate int,
   @voucherNumber varchar(50),
   @payee varchar(50),
   @amount varchar(50) = 0,
   @comments varchar(250),
   @debitAcct varchar(50) = '',
   @creditAcct varchar(50) = '',
   @officialsFundCode varchar(50) = '',
   @resultStringToken varchar(100),
   @officialName varchar(50) = '',
   @officialDepositCode varchar(50) = '',
   @officialBankCode varchar(50) = '',
   @fiscalYear varchar(50) = '',
   @theDate datetime = getdate(),
   @importStamp varchar(50),
   @tally int,
   @accountNumberBLOB varchar(max)

  select @importStamp = @ini + '_' + convert(varchar,@theDate,112) + '-' + CONVERT(varchar,@theDate,108)

  declare @wt table (
   id int,
   voucherDate int,
   voucherNumber varchar(50),
   payee varchar(50),
   amount money,
   comments varchar(250),
   debitAcct varchar(500),
   creditAcct varchar(500),
   officialsFundCode varchar(50),
   accountBlob varchar(1000),
   fiscalYear varchar(50),
   accountNumberBLOB varchar(max)
  )

  declare @results table( code int, message varchar(100) )

-- before we really get started lets check to see if we have the officials depository and bank accounts and fiscal cal and such...
  declare @code int, @message varchar(500)
  exec dbo.paymentsImportCheck
   @paymentType,
   @batchId,
   @officialName = @officialName output,
   @officialDepositCode = @officialDepositCode output,
   @officialBankCode = @officialBankCode output,
   @code = @code output,
   @message = @message output 

 exec dbo.logit @@procid, 'paymentImportCheck - result @code', @code, '@message', @message

 if @code != 0 and @paymentType <> 'warrant'
 begin
   exec dbo.logit @@procid, 'bailing @code', @code, '@message', @message
   select '@code=' + cast(@code as varchar) + ';@message=' + @message + ';'
   return
 end
 
-- insert Official Vouchers
 if @paymentType = 'official voucher'
  insert @wt select 
   id,
   cast(voucherDate as int),
   voucherNumber,
   payee,
   cast(replace(amount,'o','0') as money),
   comments,
   debitAcct,
   creditAcct,
   null,
   null,
   null,
   null
  from dbo.voucherImportBRW(@batchId)
  where rowType = 0 and postCheck = 0

-- insert Warrants
 if @paymentType = 'Warrant'
 begin
  insert @wt select 
   id,
   cast(warrantDate as int),
   warrantNumber,
   vendorCode,
   cast(replace(amount,'o','0') as money),
   '',
   debitAcct,
   creditAcct,
   clerksFund,
   null,
   fiscalYear,
   accountNumberBLOB
  from dbo.warrantImportBRW(@batchId)
  where rowType = 0 and postCheck = 0
 end

 if @debugMode = 'true'
  select * from @wt

-- check them out
  if not exists(select * from @wt)
  begin
   exec dbo.logit @@procid, 'bailing as there are no records in the workTable'
   select '@code=1;@message=No rows found to process for import;'
   return
  end

  if exists(select * from @wt where debitAcct < '  0' or creditAcct < '  0')
  begin
   exec dbo.logit @@procid, 'missing required account information'
   select '@code=1;@message=some items are missing required account information;'
   return
  end

  select @tally = count(*) from @wt
  exec dbo.logit @@procid, '=============> Beginning main loop... @tally', @tally

-- main loop
  while exists(select * from @wt)
  begin
 
    select top 1 @idToken = id, 
     @voucherDate = voucherDate,
     @voucherNumber = voucherNumber,
     @payee = payee,
     @amount = amount,
     @comments = comments,
     @debitAcct = debitAcct,
     @creditAcct = creditAcct,
     @fiscalYear = fiscalYear,
     @accountNumberBLOB = accountNumberBLOB
    from @wt order by id

   exec dbo.logit @@procid, '=============> @tally', @tally, '@payee', @payee, '@debitAcct', @debitAcct, '@creditAcct', @creditAcct

   if @debugMode = 'false'
   begin
    declare @checkPaymentId int

-- WARRANT
    if @paymentType = 'warrant'
    begin
-- get the codes from the import record
    select
     @officialDepositCode = key2,
     @officialBankCode = key3
    from object where typ = 4770 and id = @batchId

    select @checkPaymentId = 0

    select @checkPaymentId = id from object 
      where typ=4771
       and key3 = @voucherNumber
       and a4 = @debitAcct
       and a18 = 'Warrant' 
--       and a2 = @payee
--       and case when isnumeric(a1)=1 then cast(a1 as int) else 0 end = @voucherDate
       and c10 = @fiscalYear

     if isnull(@checkPaymentId,0)=0
     begin
      exec dbo.paymentCRUD 0,  
       @paymentType = @paymentType,
       @voucherDate = @voucherDate,
       @voucherNumber = @voucherNumber,
       @payee = @payee,
       @amount = @amount,
       @comments = @comments,
       @debitAcct = @debitAcct,
       @creditAcct = @creditAcct,
       @officialDepositCode = @officialDepositCode,
       @officialBankCode = @officialBankCode,
       @fiscalYear = @fiscalYear,
       @importStamp = @importStamp,
       @verbose = 'FALSE',
       @postResult = @resultStringToken output,
       @accountNumberBLOB = @accountNumberBLOB
     end
    end
-- VOUCHER   
    else
    begin
     select @checkPaymentId = id from object 
      where typ=4771 
       and key3 = @voucherNumber
       and a4 = @debitAcct
       and a18 = 'Official Voucher' 
       and a2 = @payee
       and case when isnumeric(a1)=1 then cast(a1 as int) else 0 end = @voucherDate

     if isnull(@checkPaymentId,0)=0
     begin 
      exec dbo.paymentCRUD 0,  
       @paymentType = @paymentType,
       @officialName = @officialName,
       @officialDepositCode = @officialDepositCode,
       @officialBankCode = @officialBankCode,
       @voucherDate = @voucherDate,
       @voucherNumber = @voucherNumber,
       @payee = @payee,
       @amount = @amount,
       @debitAcct = @debitAcct,
       @creditAcct = @creditAcct,
       @importStamp = @importStamp,
       @comments = @comments,
       @verbose = 'FALSE',
       @postResult = @resultStringToken output
      end
     end

     exec dbo.logit @@procid, '=============> @tally', @tally, '@result', @resultStringToken
     insert @results select dbo.readString('@code=',@resultStringToken),@resultStringToken

    end

    delete @wt where id = @idToken
    set @tally = @tally -1
  end

 if exists(select * from @results where code = 1)
  select '@code=0;@message=Finished but with errors;@clearem=false;'
 else
  select '@code=0;@message=Finished without errors;@clearem=true;'
 
 return
end