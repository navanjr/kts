create function dbo.taxrollBRW(
 @receiptId int,
 @taxYear varchar(10),
 @searchString varchar(50),
 @orderString varchar(50)
) returns @rt table(
 invoiceId int,
 name nvarchar(60),
 parcel nvarchar(34),
 taxYear numeric(5,0),
 item numeric(22,1),
 taxType nvarchar(1),
 amount varchar(50),
 due varchar(50),
 slink varchar(15),
 selectedFlag char(4),
 methodRate money,
 ord varchar(80),
 fees money,
 penalty money,
 toPay money,
 treamort varchar(5),
 taxrollId int,
 queue varchar(50),
 printed varchar(50),
 colorFlag int
)
Begin
  
set @searchString=replace(@searchstring,'~{','''')

  declare @sSLen int
   select @sSLen = LEN(@searchString)



  declare @showPaidFlag char(1) = substring(@orderString,3,1),
          @protest varchar(10) = '',
          @AdvSrch varchar(1) = substring(@orderString,5,1)

 if @AdvSrch=1 and left(@searchString,1)='O' and isnumeric(substring(@searchString,2,@sSlen))=1
  set @searchString=replace(@searchString  ,'o','owner=')


/*
  if substring(@orderString,4,1) = '1' 
  begin
    set @protest='PROTEST'
    set @showPaidFlag='1'
  end

*/

-- get the already selected items
  insert @rt
    select 
     a.id*-1,a.name,a.parcel,a.taxYear,a.item,a.typ,dbo.formatcurr(invoiceAmount),round(dbo.formatcurr(invoiceDue) * b.methodRate,2),
   't'+cast(a.id as varchar), case when b.methodRate = .5 then char(189) else 'x' end,b.methodRate,'a_'+cast(item as varchar)+cast(taxyear as varchar),case when invoiceDue != 0 then subInvoiceDue else 0.00 end,0,0,'',a.taxrollId,a.queue,a.printed,
     case when isnull(dbo.taxCorrectionsSF([MFGHOMEASSESSED],x.id,'056'),0) > 0 then 3 else 1 end
    from dbo.invoices a 
    join receiptLink b on a.id = b.invoiceId
    left join adtax x on a.taxrollId = x.id
    where b.receiptId = @receiptId


-- get the first 1000 rows that match the search string. IF we have a search string ordered by name or parcel
   if @searchString > '  0'
    begin
---Advanced Search 
     if @AdvSrch = 1
      insert @rt
       select  
        i.id*-1,name,parcel,taxYear,item,typ,dbo.formatCurrZero(invoiceAmount),dbo.formatCurrZero(invoiceDue),'t'+cast(i.id as varchar),'',0,
        'b_'+case when left(@searchString,@sSLen)=left(name,@sSLen) then '' else 'zzzz' end+case when left(@orderString,2) = '10' then name else parcel end,
        case when invoiceDue != 0 then subInvoiceDue else 0.00 end,0,0,'',
        taxrollId,queue,printed,0
       from dbo.invoices i
        where i.invoiceId = 0 
        and id in (select invoiceId from dbo.taxrollBRWIds(@taxYear,@searchString,@AdvSrch))
        and 0 = case when invoiceDue != 0 then 0 else case when @showPaidFlag = '1' then 0 else 1 end end
        and status<>'Firstnum'
        and 0 = case when @protest<>'PROTEST' then 0 else case when dbo.invoiceProtestBalance('t'+cast(i.id as varchar(15)),null)>0 then 0 else 1 end end
        and i.id not in (select invoiceId from receiptlink where receiptid = @receiptId)
     else
---Regular Search 
      insert @rt
       select  
        id*-1,name,parcel,taxYear,item,typ,dbo.formatCurrZero(invoiceAmount),dbo.formatCurrZero(invoiceDue),'t'+cast(id as varchar),'',0,'b_'+case when left(@searchString,@sSLen)=left(name,@sSLen) then '' else 'zzzz' end+case when left(@orderString,2) = '10' then name else parcel end,case when invoiceDue != 0 then subInvoiceDue else 0.00 end,0,0,'',taxrollId,queue,printed,0 
       from dbo.invoices
       where 
        name+' '+parcel+' '+cast(taxyear as varchar(4))+cast(item as varchar)+'0'+cast(item as varchar) like '%'+@searchString+'%'
        and 0 = case when invoiceDue != 0 then 0 else case when @showPaidFlag = '1' then 0 else 1 end end
        and status<>'Firstnum'
        and 0 = case when @protest<>'PROTEST' then 0 else case when dbo.invoiceProtestBalance('t'+cast(id as varchar(15)),null)>0 then 0 else 1 end end
        and taxyear = case when @taxyear = 'all' then taxyear else cast(@taxyear as numeric) end
        and id not in (select invoiceId from receiptlink where receiptid = @receiptId)   
    end
-- get the first 1000 rows with out using a search string.  ordered by name  why would you ever do this?
   else
     insert @rt
     select top 1000 
      id*-1,name,parcel,taxYear,item,typ,dbo.formatCurrZero(invoiceAmount),dbo.formatCurrZero(invoiceDue),'t'+cast(id as varchar),'',0,'b_'+case when left(@orderString,2) = '10' then name else parcel end,case when invoiceDue != 0 then subInvoiceDue else 0.00 end,0,0,'',taxrollId,queue,printed,0 
     from dbo.invoices
     where
      taxyear = case when @taxyear = 'all' then taxyear when isnumeric(@taxyear)=1 then cast(@taxyear as numeric) else 0 end
      and invoiceId = 0
      and status<>'Firstnum'
      and 0 = case when invoiceDue != 0 then 0 else case when @showPaidFlag = '1' then 0 else 1 end end
      and 0 = case when @protest<>'PROTEST' then 0 else case when dbo.invoiceProtestBalance('t'+cast(id as varchar(15)),null)>0 then 0 else 1 end end
      and id not in (select invoiceId from receiptlink where receiptid = @receiptId)


--Adtax 0 due records

  if @showPaidFlag = '1' and @searchString > '  0'
   begin
---Advanced Search 
     if @AdvSrch = 1  
       insert @rt
         select  
          (id+9000000)*-1,OWNERNAME,FULLPIDNUMBER,REALTAXYEAR,ITEMNUMBER,RECORDTYPE,0.00,0.00,'a'+cast(id as varchar),'',0,'b_'+case when left(@searchString,@sSLen)=left(OWNERNAME,@sSLen) then '' else 'zzzz' end+case when left(@orderString,2) = '10' then OWNERNAME else FULLPIDNUMBER end,0.00 ,0,0,'',id,'','',0 
         from dbo.adtax a
         inner join dbo.taxrollBRWAdTaxIds(@taxYear,@searchString,@AdvSrch) at on a.ID = adtaxId
          where a.id not in (select taxrollId from invoices)
       else
---Regular Search 
       insert @rt
         select 
          (id+9000000)*-1,OWNERNAME,FULLPIDNUMBER,REALTAXYEAR,ITEMNUMBER,RECORDTYPE,0.00,0.00,'a'+cast(id as varchar),'',0,'b_'+case when left(@searchString,@sSLen)=left(OWNERNAME,@sSLen) then '' else 'zzzz' end+case when left(@orderString,2) = '10' then OWNERNAME else FULLPIDNUMBER end,0.00 ,0,0,'',id,'','',0
         from dbo.adtax
          where 
              OWNERNAME+' '+FULLPIDNUMBER+' '+cast(REALTAXYEAR as varchar(4))+'0'+cast(ITEMNUMBER as varchar) like '%'+@searchString+'%'
              and cast(REALTAXYEAR as varchar) = case when @taxyear = 'all' then cast(REALTAXYEAR as varchar) else cast(@taxyear as numeric) end 
              and id not in (select taxrollId from invoices)

   end


  if @protest='PROTEST'
    begin
      update a set amount=p.amount from @rt a, dbo.protestDetail p where a.invoiceId=p.invoiceId*-1
    end

-- Set Mortgage Codes
   update @rt set
    treamort = 
     case when a.treamort>'  0' then cast(a.treamort as varchar(5)) else 
     case when mortgagecode=0 then '' else cast(mortgagecode as varchar(50)) end end 
   from adtax a where taxrollid=a.id and taxType not in ('A','S')

  declare @interestToDate int

  if left(@searchString,12)='Interest To:'
   begin
    select @interestToDate = dbo.clariondate(substring(@searchString,14,10))
   end
  else
   begin
    select @interestToDate = dbo.clariondate(getdate())
   end

-- Remove voided invoices that have been reissued
  delete from @rt where cast(amount as money)=0.00 and cast(due as money) = 0.00 and taxrollid in (select taxrollid from @rt where cast(amount as money)<>0.00)  


  if exists(select * from receiptLink where receiptId = @receiptId)
  begin
   update a set 
    fees = isnull((select sum(i.invoiceDue) from invoices i where i.invoiceId=a.invoiceId*-1 and i.typ='f'),0),
    penalty = round((cast(due as money)*dbo.penaltyPercent(invoiceId*-1,dbo.date1(@interestToDate))/100),2)
   from @rt a where selectedFlag in (char(189),'x')
 
  update a set
    toPay = round(cast(due as money),2)+fees+penalty
     from @rt a where selectedFlag in (char(189),'x')
   
   insert @rt (invoiceId,name,ord,amount,due,fees,penalty,parcel,colorFlag) 
   select 0,'--Selected--  Count: '+cast(count(invoiceId) as varchar),' _',dbo.formatcurr(sum(cast(amount as money))),dbo.formatcurr(sum(cast(due as money))),sum(fees),sum(penalty),'--Grand Total: '+convert(varchar,sum((topay)),1),2
   from @rt where selectedFlag > '  0'

   insert @rt (invoiceId,name,ord) select 0,'','a_zzzzzzz'
  end

 return

end