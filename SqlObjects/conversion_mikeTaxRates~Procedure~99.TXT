create proc dbo.conversion_mikeTaxRates(
 @mode varchar(50) = 'conversion',
 @method varchar(5) = 'GET',
 @class varchar(50) = null output,
 @code int = 0 output,
 @message varchar(100) = null output,
 @tally int = 0 output,
 @fixProc varchar(100) = null output,
 @guide varchar(100) = null output
) as 
begin
 set nocount on

 if @mode != 'conversion'
  return

 if @method = 'GET'
 begin  
  select 
   @class = 'conversion',
   @guide = 'GET|SHOW|FIX',
   @code = case when count(*) = 0 then 1 else 0 end,
   @tally = 1,  
   @message = 'tax rates not found in KTS'
  from object
  where typ = 4012

  return

 end


  declare
   @mikeTableName varchar(50),
   @mikePath varchar(max) = dbo.settingsF('conversion.mikepathtax',''),
   @sql nvarchar(max),
   @sql1 nvarchar(max),
   @sql2 nvarchar(max),
   @sql3 nvarchar(max)

  select
   @sql1 = 'select * from openrowset(''VFPOLEDB'',''' + @mikePath + '\',
   @sql2 = '.dbf' + ''';'''';'''',''SELECT * FROM ',
   @sql3 = ' where !deleted()'')'

  declare @districtNames table(
   id int identity(1,1),
   district varchar(50),
   rateName varchar(50),
   totalMills decimal(19,10),
   year int,
   flag int 
  )
  declare @rates table(
   id int identity(1,1),
   impLink int,
   district varchar(50),
   districtId int,
   rateName varchar(50),
   rateNameId int,
   rateCol varchar(50),
   mill decimal(19,10),
   rate decimal(19,10),
   processFlag int,
   year int 
  )
  declare @appsch01 TABLE(
	[sch_n] [char](3) NULL,
	[city_c] [char](5) NULL,
	[year] [char](4) NULL,
	[name] [char](15) NULL,
	[c4mil] [char](1) NULL,
	[totmil] [numeric](8, 2) NULL,
	[order] [char](3) NULL,
	[postdist] [char](5) NULL,
	[postvtec] [char](5) NULL,
	[postcity] [char](5) NULL,
	[dname] [char](15) NULL
  )

  set @mikeTableName = 'appsch01'
  set @sql = @sql1 + @mikeTableName + @sql2 + @mikeTableName + @sql3
  insert @appsch01 exec(@sql)
  exec dbo.logit @@procid, 'insert into appsch01  @@rowcount', @@rowcount
 
  declare @appsch02 table(
	[sch_n] [char](3) NULL,
	[city_c] [char](5) NULL,
	[year] [char](4) NULL,
	[lineitem] [char](2) NULL,
	[mil] [numeric](7, 4) NULL,
	[ovr] [numeric](9, 8) NULL
  ) 

  set @mikeTableName = 'appsch02'
  set @sql = @sql1 + @mikeTableName + @sql2 + @mikeTableName + @sql3
  insert @appsch02 exec(@sql)
  exec dbo.logit @@procid, 'insert into appsch02  @@rowcount', @@rowcount

  declare @picklistLineItems TABLE(
	[type] [char](10) NULL,
	[iden] [char](4) NULL,
	[val1] [char](50) NULL,
	[val2] [char](20) NULL,
	[val3] [char](10) NULL,
	[desc] [char](50) NULL,
	[template] [text] NULL
  )

  set @mikeTableName = 'picklist'
  set @sql = @sql1 + @mikeTableName + @sql2 + @mikeTableName + ' where !deleted()  and type="LINEITEM"'')' 
  insert @picklistLineItems exec(@sql)
  exec dbo.logit @@procid, 'insert into picklistItems  @@rowcount', @@rowcount

  declare @taxTXLV TABLE(
	[sch_n] [char](3) NULL,
	[city_c] [char](5) NULL,
	[year] [char](4) NULL,
	[lineitem] [char](2) NULL,
	[mil] [numeric](7, 4) NULL,
	[ovr] [numeric](9, 8) NULL,
	[type] [char](10) NULL,
	[iden] [char](4) NULL,
	[val1] [char](50) NULL,
	[val2] [char](20) NULL,
	[val3] [char](10) NULL,
	[desc] [char](50) NULL,
	[template] [text] NULL,
	[postdist] [char](5) NULL,
	[postvtec] [char](5) NULL,
	[postcity] [char](5) NULL,
	[dname] [char](15) NULL
  )

  insert @taxTXLV
  select a.*,b.*,c.[postdist],c.[postvtec],c.[postcity],c.[dname]
  from
   @appsch02 a,
   @picklistlineitems b,
   @appsch01 c 
  where a.lineitem=b.iden and a.sch_n=c.sch_n and a.city_c=c.city_c and a.year=c.year
  exec dbo.logit @@procid, 'insert into taxTXLV  @@rowcount', @@rowcount

  insert @districtNames 
  select postdist,city_c,sum(mil),year,0 
  from @taxTXLV group by postdist,city_c,year

-- import rates
  insert @rates (impLink,district,rateName,rateCol,mill,rate,processFlag,year)
  select 0,ltrim(b.postdist),ltrim(b.city_c),b.val1,b.mil,0.0,0,b.year 
-- use this if missing city in taxrates
--  select 0,ltrim(b.postdist),ltrim(b.sch_n),b.val1,b.mil,0.0,0,b.year 
  from @taxTXLV b 
  exec dbo.logit @@procid, 'insert into rates  @@rowcount', @@rowcount

  update a set implink=b.id 
  from @rates a, @districtnames b where a.district = b.district and a.rateName = b.rateName and a.year = b.year
  exec dbo.logit @@procid, 'update rates  @@rowcount', @@rowcount

  update @districtNames set flag = 1 

  declare
   @colToken varchar(50),
   @distToken varchar(50),
   @rToken varchar(50),
   @idToken varchar(150),
   @millToken numeric(19,10),
   @rateToken numeric(19,10),
   @yearToken int,
   @objectInsertedTally int = 0,
   @objectUpdatedTally int = 0,
   @rowTally int

  declare @districtUnique table(id int identity(1,1),district varchar(50))
  insert @districtUnique 
  select distinct postdist from @taxTXLV where postdist > ' 0'
  exec dbo.logit @@procid, 'insert into districtUnique  @@rowcount', @@rowcount

-- loop to create glAccounts
  while (select COUNT(*) from @districtUnique) > 0
  begin
   select top 1 @idToken = id from @districtUnique

   select 
    @distToken = district
   from @districtUnique where id = @idToken

   exec glAccountVerification @distToken,'SCHOOL','CREATE'
  -- exec glAccountVerification @rToken,'CITY','CREATE'

   delete @districtUnique where id = @idToken
 
  end

  delete @rates where mill = 0
  exec dbo.logit @@procid, 'delete rates where mill = 0 @@rowcount', @@rowcount
  update @rates set rate = mill / (select totalMills from @districtNames where id = impLink)
  exec dbo.logit @@procid, 'update rates set rate = mill/totalmills @@rowcount', @@rowcount

-- prepare for import to object table
  update a set a.districtId = b.id from @rates a, Object b where rtrim(a.district) = rtrim(b.Key1) and b.Typ = 4701 and b.a1='SCHOOL'
  exec dbo.logit @@procid, 'udpates to object #1 districtId...  @@rowcount', @@rowcount
  update a set a.rateNameId = b.id from @rates a, Object b where rtrim(a.rateName) = rtrim(b.Key1) and b.Typ = 4011
  exec dbo.logit @@procid, 'udpates to object #2 rateNameId...  @@rowcount', @@rowcount


 if @method = 'SHOW'
 begin  

--  select * from @picklistLineItems
/* -- use this to create tax rate names if noTax
  insert object (typ,key1)
  select 4011, sch_n from @taxTXLV
   where sch_n not in (select key1 from object where typ = 4011)
   group by sch_n
*/
--  select * from @taxTXLV
--  select * from @appsch02
  select * from @rates
--  select * from object where typ = 4012

  return

 end

 if @method = 'FIX'
 begin  
  exec dbo.logit @@procid, 'Running conversion...'


-- remove any rates that wont import
  delete @rates where ISNULL(districtId,0)=0 
  exec dbo.logit @@procid, 'delete rates #1...  @@rowcount', @@rowcount
  delete @rates where ISNULL(rateNameId,0)=0 
  exec dbo.logit @@procid, 'delete rates #2...  @@rowcount', @@rowcount

-- turn off the trigger on object
  alter table object disable trigger keySqlObjectWriteToRepoTR
  exec dbo.logit @@procid, 'Disable Trigger on Object'

  select @tally = count(*) from @rates
  exec dbo.logit @@procid, 'looping thru rates @rowTally', @rowTally
  
  begin transaction
   while exists(select * from @rates)
   begin
    select top 1 
     @idToken = id, @distToken = district, @rToken = rateName, @colToken = rateCol, @millToken = mill, @rateToken = rate, @yearToken = [year]
    from @rates
    if exists(select * from Object where typ = 4012 and Key1 = @distToken and Key2 = @rToken and Key3 = @yearToken and A1 = @colToken)  
    begin
     update Object set A2 = @millToken, A3 = @rateToken
     where typ = 4012 and Key1 = @distToken and Key2 = @rToken and Key3 = cast(@yearToken as varchar(5)) and A1 = @colToken
     set @objectUpdatedTally = @objectUpdatedTally + 1
    end
    else
    begin
     insert object (typ,key1,link1,key2,link2,key3,a1,a2,a3)
     select 4012,district,districtId,rateName,rateNameId,cast(@yearToken as varchar(5)),rateCol,cast(mill as varchar(50)),isnull(cast(rate as varchar(50)),'')
     from @rates where id = @idToken
     set @objectInsertedTally = @objectInsertedTally + 1
    end

    delete @rates where id = @idToken
 
   end
  commit transaction
  exec dbo.logit @@procid, 'object stats...  @objectInsertedTally', @objectInsertedTally, '@objectUpdatedTally', @objectUpdatedTally

-- turn the trigger back on object
  alter table object enable trigger keySqlObjectWriteToRepoTR
  exec dbo.logit @@procid, 'Enable Trigger on Object'

  return

 end

end








