create procedure dbo.receiptTaxStageGL (@receiptId int, @mode int = 0, @returncode varchar(300) = '' output) as
begin
 declare @receiptSlink varchar(15) = 'o' + cast(@receiptId as varchar)

 declare @wt table(id int identity(1,1),
  linkid int,
  invoiceId int,
  slink varchar(15),
  invoiceSLink varchar(15),
  taxYear varchar(10),
  due money default 0,
  methodRate money,
  applyAmount money default 0,
  arAccountId int,
  contraAccountId int,
  processFlag int default 0,
  protestAmount money,
  protestId int,
  sourceCode varchar(60),
  fundCode varchar(60),
  invoiceTyp varchar(1),
  pertyp varchar(1),
  payord int,
  parentInvoiceId int
 )
 declare @glFundDebits table(
  slink varchar(15),
  fundCode varchar(50),
  accountId int,
  amount money,
  prorate decimal(19,18),
  payAmount decimal(19,10),
  contraId int,
  due money,
  protestAmount money,
  protestId int,
  slink2 varchar(15),
  sourceCode varchar(60)
 )
 declare @glSalesCredits table(
  slink varchar(15),
  accountId int,
  amount money,
  contraId int,
  comment varchar(50)
 )
 declare @glSuspense table(
  slink varchar(15),
  accountId int,
  amount money,
  slink2 varchar(15)
 )
 declare @glStage table(
  slink varchar(15),
  accountId int,
  amount money,
  contraId int,
  processType varchar(50),
  slink2 varchar(15),
  sourceCode varchar(60),
  comment varchar(50)
 )

 declare
  @paidTotal money,
  @idToken int,
  @dueToken money,
  @specificApplyAmountToken money,
  @amountToken money,
  @taxId int,
  @currTaxId int,
  @priorTaxId int,
  @backTaxId int,
  @currTaxCode varchar(50),
  @protestTaxCode varchar(50),
  @priorTaxCode varchar(10),
  @protest varchar(10),
  @contraCodeSuffix varchar(50),
  @protestCodeSuffix varchar(50),
  @sourceCode varchar(60),
  @slink2 varchar(15),
  @applyTotal money,
  @prorate decimal(19,18),
  @processCount int,
  @suspenseMethod varchar(50),
  @message varchar(250)

 select @suspenseMethod = dbo.readstring('@suspenseMethod=',dbo.whoAmI())

--TODO: bail if there is already gldetail for these receiptLinks 
--TODO: bail if we are offered too much money

  select @protest=isnull(b15,'') from object where typ=4502 and id=@receiptId

  set @contraCodeSuffix='_ADVALOREM'
  set @protestCodeSuffix='_PROTEST'

-- get the invoices linked to this receipt
 insert @wt (
  linkId, invoiceId, slink, invoiceSLink, methodRate, taxyear, protestAmount, protestId,
  sourceCode, invoiceTyp, pertyp, payord, parentInvoiceId)
  select
   a.id,
   a.invoiceId,
   'l'+cast(a.id as varchar),
   't'+cast(a.invoiceId as varchar),
   a.methodRate,
   b.taxYear,
   a.protestAmount,
   0,
   case when b.invoiceId>0 then 'GETSOURCE' else '' end,
   b.typ,
   case when b.typ='O' then isnull((select top 1 pertyp from adtax where id=b.taxrollId),'') else '' end,
   case when b.invoiceId > 0 then 1 else 2 end,
   b.invoiceId
  from receiptLink a, invoices b 
  where a.invoiceId = b.id 
    and a.receiptId = @receiptId
    and b.typ not in  ('S','A')

 insert @wt (linkId, invoiceId, slink, invoiceSLink, due, methodRate, taxyear, protestAmount, protestId, sourceCode, fundCode, invoiceTyp, payord, parentInvoiceId)
  select
   a.id,
   a.invoiceId,
   'l'+cast(a.id as varchar),
   't'+cast(a.invoiceId as varchar),
   r.amount,
   a.methodRate,
   b.taxYear,
   a.protestAmount,
   0,
   r.sourceCode,
   r.fundCode,
   b.typ,
   case when b.invoiceId > 0 then 1 else 2 end,
   b.invoiceId
  from receiptLink a, invoices b, receiptDetail r 
  where a.invoiceId = b.id 
    and a.receiptId = @receiptId
    and b.typ = 'S'
    and r.slink='t'+cast(a.invoiceId as varchar)

-- calculate the balance due, update AR and Contra account id


  declare @caccts table(id int identity(1,1),
 accountId int,
 accountCode varchar(60),
 processflag int,
 invoiceTyp varchar(1),
 pertyp varchar(1),
 protestId int,
 protestCode varchar(60)
)

  insert @caccts 
   select distinct 0,rtrim(key3),0,left(a2,1), left(a3,1),0,rtrim(key3)+@protestCodeSuffix
    from object 
      where typ=4503 and left(key1,3)='TAX' and a2 in (select invoiceTyp from @wt) and key3 > ' 0'
  insert @caccts 
   select distinct 0,rtrim(taxyear)+@contraCodeSuffix,0,'','',0,'' from @wt
  insert @caccts 
   select distinct 0,rtrim(taxyear)+@protestCodeSuffix,0,'','',0,'' from @wt where protestAmount<>0.00

 while exists(select * from @caccts where processflag=0)
 begin
  select top 1 
    @idToken = id,
    @currTaxCode = accountCode,
    @protestTaxCode = protestCode
   from @caccts where processflag=0
  exec glAccountVerification @currTaxCode, 'FUND', 'CREATE', @collectionDesc='Ad'
  exec dbo.receiptAccountsVerification @currTaxCode, 'TAX'

  if @protestTaxCode > ' 0'
   begin 
    exec glAccountVerification @protestTaxCode, 'FUND', 'CREATE', @collectionDesc='Ad'
    exec dbo.receiptAccountsVerification @protestTaxCode, 'TAX'
   end

  update @caccts set processflag=1 where id = @idToken
 end

 update c set accountId = a.accountId from @caccts c, glaccounts a where c.accountCode=a.accountCode 

 update c set protestId = a.accountId from @caccts c, glaccounts a where c.protestCode=a.accountCode 

 update @wt set processflag=0 where processflag=1

 update w set contraAccountId = c.accountId from @wt w, @caccts c 
    where c.invoicetyp > '0' 
     and c.pertyp>'0' 
     and w.invoicetyp=c.invoicetyp 
     and w.pertyp=c.pertyp
     and isnull(contraAccountId,0) = 0

 update w set contraAccountId = c.accountId from @wt w, @caccts c 
    where c.invoicetyp > '0' 
     and c.pertyp<'0' 
     and w.invoicetyp=c.invoicetyp 
     and isnull(contraAccountId,0) = 0

 update w set protestId = c.protestId from @wt w, @caccts c 
    where c.invoicetyp > '0' 
     and c.pertyp>'0' 
     and w.invoicetyp=c.invoicetyp 
     and w.pertyp=c.pertyp
     and isnull(w.protestId,0) = 0
     and w.protestAmount > 0

 update w set protestId = c.protestId from @wt w, @caccts c 
    where c.invoicetyp > '0' 
     and c.pertyp<'0' 
     and w.invoicetyp=c.invoicetyp 
     and isnull(w.protestId,0) = 0
     and w.protestAmount > 0

 update w set contraAccountId = pi.contraAccountId, protestId=pi.protestId 
   from @wt w, @wt pi
   where w.parentInvoiceId=pi.invoiceId


 update @wt set
  due = case when invoiceTyp not in ('S','A') then round((select sum(due) from dbo.invoiceCheck(invoiceId)),2) else due end,
  arAccountId = (select arAccountId from dbo.invoiceCheck(invoiceId)),
  contraAccountId = case when isnull(contraAccountId,0) = 0 then isnull((select accountId from glAccounts where accountCode = rtrim(taxyear)+@contraCodeSuffix),0)
     else contraAccountId end,
  protestId = case when protestAmount > 0 and isnull(protestId,0) < 1 
      then isnull((select accountId from glAccounts where accountCode = rtrim(taxyear)+@protestCodeSuffix),0) else isnull(protestId,0) end
   where invoiceId > 0

-- populate Suspense
-- get all the payments linked to this receipt
 if @suspenseMethod in ('U','S')
 begin
  insert @glSuspense
  select @receiptSlink, b.accountId, round(sum(a.amount),2), 'p'+cast(a.id as varchar(14))
   from paid a, dbo.posAccounts(dbo.posName(@receiptId)) b 
   where a.paycode = b.paycode and b.receiptType = 'TAX' and a.slink = @receiptSlink group by b.accountId, a.id
 end
 else
 begin
  insert @glSuspense
  select @receiptSlink, b.accountId, round(sum(a.amount),2), 'p'+cast(a.id as varchar(14))
   from paid a, paycodes b 
   where a.paycode = b.paycode and a.slink = @receiptSlink group by b.accountId, a.id
 end




-- select @paidTotal = round(sum(amount),2) from @glSuspense

-- select @paidTotal

-- Determine ETR Payments
  declare @etrPaid numeric(19,10), @otherPaid numeric(19,10), @etrPercent numeric(19,10), @otherPercent numeric(19,10), @etrCode varchar(60)

  select @otherPaid = sum(amount) from paid where slink = @receiptSlink and paycode not in (select key1 from object where typ=4505 and a2 in ('E','C','B'))
  select @etrPaid = sum(amount) from paid where slink = @receiptSlink and paycode in (select key1 from object where typ=4505 and a2 in ('E','C','B'))
  select @paidTotal = isnull(@otherPaid,0)+isnull(@etrPaid,0)
  select top 1 @etrCode = paycode from paid where slink = @receiptSlink and paycode in (select key1 from object where typ=4505 and a2 in ('E','C','B'))
  select @etrPercent = case when @paidTotal>0 then isnull(@etrPaid,0)/@paidTotal else 0 end
  select @otherPercent = case when @paidTotal > 0 then isnull(@otherPaid,0)/@paidTotal else 0 end


 exec dbo.logit @@procid, '@paidTotal = ', @paidTotal, @level = 2 
 exec dbo.logit @@procid, '@OtherPaid = ', @OtherPaid, @level = 2 
 exec dbo.logit @@procid, '@ETRPaid = ', @ETRPaid, @level = 2 
 exec dbo.logit @@procid, '@OtherPercent = ', @OtherPercent, @level = 2 
 exec dbo.logit @@procid, '@ETRPercent = ', @ETRPercent, @level = 2 

 while exists(select * from @wt where processFlag = 0 and methodRate > 1.0)
 begin
  select top 1 @idToken = id, @dueToken = case when methodrate > due then due else methodrate end from @wt where processFlag = 0 and methodRate > 1.0 order by methodRate desc, payord, due, linkId

  exec dbo.logit @@procid, '@paidTotal = ', @paidTotal, @level = 2 

-- @paidTotal > 0 are normal items...
  if @paidTotal > 0
  begin
   if @dueToken <= @paidTotal
    update @wt set applyAmount = @dueToken where id = @idToken
   else
    update @wt set applyAmount = @paidTotal where id = @idToken

   exec dbo.logit @@procid, '@dueToken = ', @dueToken, @level = 2 

   if @dueToken <= @paidTotal
    set @paidTotal = @paidTotal - @dueToken
   else
    begin
     set @paidTotal = 0
     set @message = 'You have not taken in as much money as is expected. Please review your specified amount payments and correct them as necessary.'
    end

  end
  update @wt set processFlag = 1 where id = @idToken
 end


 while exists(select * from @wt where processFlag = 0 and methodRate = 1.0)
 begin
  select top 1 @idToken = id, @dueToken = round(due * methodRate,2) from @wt where processFlag = 0 and methodRate = 1.0 order by methodRate desc, payord, due, linkId

  exec dbo.logit @@procid, '@paidTotal = ', @paidTotal, @level = 2 

-- @paidTotal > 0 are normal items...
  if @paidTotal > 0
  begin
   if @dueToken <= @paidTotal
    update @wt set applyAmount = @dueToken where id = @idToken
   else
    update @wt set applyAmount = @paidTotal where id = @idToken

   exec dbo.logit @@procid, '@dueToken = ', @dueToken, @level = 2 

   if @dueToken <= @paidTotal
    set @paidTotal = @paidTotal - @dueToken
   else
    begin
     set @paidTotal = 0
     set @message = 'You have not taken in as much money as is expected. Please review your full pay items and see if you should mark some as half pay.'
    end

  end
  update @wt set processFlag = 1 where id = @idToken
 end
-- if len(isnull(@message,''))>2
-- begin
--  select '@code=1;@message='+@message+';'
-- end

  select @applyTotal = sum(round(due*methodRate,2)) from @wt where processFlag = 0
   exec dbo.logit @@procid, '@applyTotal = ', @applyTotal, @level = 2 

  if @paidTotal > @applyTotal and @paidTotal > 0.00
   begin
    set @prorate = @paidTotal/@applyTotal
   end
  else
   begin
    set @prorate = 1.0000000
   end 

   exec dbo.logit @@procid, '@prorate = ', @prorate, @level = 2 



 while exists(select * from @wt where processFlag = 0)
 begin
  select @processCount = count(*) from @wt where processFlag = 0
   exec dbo.logit @@procid, '@processCount = ', @processCount, @level = 2 


  select top 1 @idToken = id, @dueToken = round(due * methodRate * @prorate,2) from @wt where processFlag = 0 order by methodRate desc, payord, due, linkId
  if @paidTotal > 0
  begin
   exec dbo.logit @@procid, '@paidTotal = ', @paidTotal, @level = 2 
   if @dueToken <= @paidTotal
    update @wt set applyAmount = @dueToken where id = @idToken
   else
    begin
     update @wt set applyAmount = @paidTotal where id = @idToken
     set @message = 'You have not taken in as much money as is expected. Please review your half pay items. You do not have enough money to pay a full 50%.'
    end

   exec dbo.logit @@procid, '@dueToken = ', @dueToken, @level = 2 

   if @dueToken <= @paidTotal
    set @paidTotal = @paidTotal - @dueToken
   else
    set @paidTotal = 0

   if @processCount = 1 and @paidTotal>.004 
    begin
     update @wt set applyAmount = applyAmount + @paidTotal where id = @idToken and due > (applyAmount+@paidTotal)
    end


  end
  update @wt set processFlag = 1 where id = @idToken
 end

-- Set source code on worktable for subinvoices
 update b set sourceCode = isnull((select top 1 a.sourceCode from receiptDetail a where a.slink=b.invoiceSLink),'') from @wt b where b.sourceCode='GETSOURCE'

-- populate fundDebits
-- add the debit to funds accounts from the invoice detail
 insert @glFundDebits
 select
  c.slink, a.fundCode, 0, round(sum(a.amount),2) as amount,max(c.applyAmount/c.due),max(c.applyAmount), c.contraAccountId, c.due, c.protestAmount, c.protestId, case when c.protestAmount > 0.00 then c.invoiceSLink else '' end,c.sourceCode
 from receiptDetail a, @wt c 
 where a.slink = c.invoiceSLink and c.due<>0.00 and c.invoiceTyp<>'S'
 group by c.slink, a.slink, a.fundCode, c.contraAccountId,c.due, c.protestAmount, c.protestId, c.invoiceSLink,c.sourceCode

 insert @glFundDebits
 select
  c.slink, c.fundCode, 0, round(sum(c.due),2) as amount,max(c.applyAmount/c.due),max(c.applyAmount), c.contraAccountId,
  c.due,
  c.protestAmount, c.protestId, case when c.protestAmount > 0.00 then c.invoiceSLink else '' end,c.sourceCode
 from @wt c 
 where
   c.due <> 0.00 and c.invoiceTyp = 'S' 
 group by
  c.slink, c.fundCode, c.contraAccountId,
  c.due, 
  c.protestAmount, c.protestId, c.invoiceSLink,c.sourceCode

 update @glFundDebits set amount=due where abs(amount)>abs(due)
 update @glFundDebits set payamount=due where abs(payamount)>abs(due)
 update @glFundDebits set protestAmount=due where abs(protestAmount)>abs(due)

-- change contra account for protested tax money
 insert @glFundDebits (slink, fundCode, accountId, amount, prorate, payAmount, contraId, due, protestAmount, protestId, slink2, sourceCode)
    select slink, fundCode, accountId, protestAmount, prorate, protestAmount, protestId, protestAmount, 0,0, slink2, sourceCode from @glFundDebits where protestAmount>0
 update @glFundDebits set amount=amount-protestAmount, payamount=payamount-protestAmount, slink2='' where protestAmount>0
-- remove lines with no amounts
 delete from @glFundDebits where amount=0.00 and payamount=0.00

-- update the fundDebits with the proper accountId
 update a set a.accountId = b.accountId
  from @glFundDebits a, glAccounts b
  where a.fundCode>' 0' and a.fundCode = b.targetAccountCode and b.accountType='ACCRUED RECEIVABLE'
    and right(a.fundCode,4) <> '_ACR'

 update a set a.accountId = b.accountId 
  from @glFundDebits a, glAccounts b
  where a.fundCode >' 0' and a.fundCode = b.accountCode and a.accountId = 0

 if exists(select * from @glFundDebits where fundCode<' 0')
  begin
   select '@code=1;@message=Fund Code Information Missing;'
   return
  end
  
-- begin test code here
if @mode = 1
begin
-- select * from receiptlink where receiptId = @receiptId
-- select * from receiptDetail where slink in (select slink from dbo.receiptSlinks(@receiptId))
-- select * from @wt

 select
  c.slink, c.fundCode, 0, round(sum(c.due),2) as amount,max(c.applyAmount/c.due),max(c.applyAmount), c.contraAccountId,
  c.due,
  c.protestAmount, c.protestId, case when c.protestAmount > 0.00 then c.invoiceSLink else '' end,c.sourceCode
 from @wt c 
 where
   c.due <> 0.00 and c.invoiceTyp = 'S' 
 group by
  c.slink, c.fundCode, c.contraAccountId,
  c.due, 
  c.protestAmount, c.protestId, c.invoiceSLink,c.sourceCode


 select * from @glFundDebits
 
 select @receiptSlink, b.contraId, sum(b.payAmount), null, COUNT(*)
 from @wt a, @glFundDebits b
 where a.slink = b.slink 
  and a.invoiceTyp='S' 
  and a.sourceCode=b.sourceCode
  and a.fundCode=b.fundCode
 group by b.slink, b.contraId, a.slink, a.id

 select *
 from @wt a, @glFundDebits b
 where a.slink = b.slink
  and a.fundCode=b.fundCode

 select *
 from @wt a, @glFundDebits b
 where a.slink = b.slink 
  and a.invoiceTyp<>'S'


end
-- end test code here

-- add the credit to the Treasures collection Account and include the contraId to the receiptLink parent
 insert @glSalesCredits 
 select @receiptSlink, b.contraId, round(sum(round(b.payAmount,2))*-1*@otherPercent,2), null,''
 from @wt a, @glFundDebits b
 where a.slink = b.slink 
  and a.invoiceTyp<>'S'
 group by b.contraId--,b.slink,  a.slink--, a.id

 insert @glSalesCredits 
 select @receiptSlink, b.contraId, round(sum(round(b.payAmount,2))*-1*@otherPercent,2), null,''
 from @wt a, @glFundDebits b
 where a.slink = b.slink 
  and a.invoiceTyp='S' 
  and a.sourceCode=b.sourceCode
  and a.fundCode=b.fundCode
 group by b.contraId--,b.slink,  a.slink--, a.id

 insert @glSalesCredits 
 select @receiptSlink, b.contraId, round(sum(b.payAmount)*-1,2)-round(sum(round(b.payAmount,2))*-1*@otherPercent,2), null, @etrCode
 from @wt a, @glFundDebits b
 where a.slink = b.slink 
  and a.invoiceTyp<>'S'
 group by b.contraId--,b.slink,  a.slink--, a.id

 insert @glSalesCredits 
 select @receiptSlink, b.contraId, round(sum(b.payAmount)*-1,2)-round(sum(round(b.payAmount,2))*-1*@otherPercent,2), null, @etrCode
 from @wt a, @glFundDebits b
 where a.slink = b.slink 
  and a.invoiceTyp='S' 
  and a.sourceCode=b.sourceCode
  and a.fundCode=b.fundCode
 group by b.contraId--,b.slink,  a.slink--, a.id

-- Check to be sure the ETR total matches the payment records
 declare @salesContraETRTotals money, 
         @ETRDifference money,
         @tokenSlink varchar(16),
         @tokenAccountId int

 select @salesContraETRTotals = sum(amount)*-1 from @glSalesCredits where comment=@etrCode

 if @salesContraETRTotals<>@etrPaid
 begin
  select @ETRDifference = @salesContraETRTotals-@etrPaid
  select top 1 @tokenSlink = slink,
               @tokenAccountId = accountId 
     from @glSalesCredits where comment=@etrCode

  update @glSalesCredits set amount=amount+@ETRDifference 
    where slink=@tokenSlink
     and accountId=@tokenAccountId
     and comment=@etrCode

  update @glSalesCredits set amount=amount-@ETRDifference 
    where slink=@tokenSlink
     and accountId=@tokenAccountId
     and comment<>@etrCode
 end


-- add the credit to AR Accounts
 insert @glSalesCredits 
 select b.slink, a.arAccountId, round(sum(b.payAmount)*-1,2), null, ''
 from @wt a, @glFundDebits b
 where a.slink = b.slink
  and a.invoiceTyp<>'S'
 group by b.slink, a.arAccountId, a.id

 insert @glSalesCredits 
 select b.slink, a.arAccountId, round(sum(b.payAmount)*-1,2), null, '' 
 from @wt a, @glFundDebits b
 where a.slink = b.slink
  and a.invoiceTyp='S' 
  and a.sourceCode=b.sourceCode
  and a.fundCode=b.fundCode
 group by b.slink, a.arAccountId, a.id

-- echo the guts of this proc and bail if you are in test mode
 if @mode = 1
 begin
  select * from @glSalesCredits
--  return
 end


 insert @glStage
  select slink,accountId,round(sum(payAmount),2) as payAmount,contraId,'fundDebit',slink2,sourceCode,'' from @glFundDebits group by slink,accountId,contraId,slink2,sourceCode
 union all
  select slink,accountId,round(SUM(amount),2),contraId,'salesCredit','','',comment from @glSalesCredits group by slink, accountId, contraId, comment
 union all
  select slink,accountId,amount,null,'suspense',slink2,'','' from @glSuspense

 declare
  @balance money,
  @tally int,
  @log varchar(max)
 select @balance = sum(amount), @tally = count(*) from @glStage
 if @balance != 0
 begin
  select @log = 'Count:' + cast(count(*) as varchar) + ';Balance:' + cast(sum(amount) as varchar) + ';' from @glStage
  exec dbo.logit @@procId, '@glStage table is out of balance', @log

  insert @glStage
  select @receiptSlink, 0, @balance * -1,0, 'Temporarly Suspend Balance', '', '',''
 end

-- echo the guts of this proc and bail if you are in test mode
 if @mode = 1
 begin
  select * from @glStage
  return
 end

-- remove any existing stage records
 delete glDetailStage where slink in (select slink from @glStage union select slink from dbo.receiptSLinks(@receiptId) where left(slink,1)<>'t')

-- insert
 insert gldetailstage (slink,accountId,amount,contraId,slink2,sourceCode,comment) select slink, accountId, round(amount,2), contraId, slink2, sourceCode, comment from @glStage where amount != 0
 
 update a set
  a.accountCode = b.accountCode,
  a.accountDesc = b.accountDesc
 from glDetailStage a, glAccounts b
 where a.accountId = b.accountId
  and a.slink in (select slink from @glStage)

 select @balance = sum(amount) from gldetailstage where slink in (select slink from @glStage)
 if @balance != 0
  exec dbo.logit @@procid, 'Oops, we have a problem...  @balance', @balance

 set @returncode = @message

end