create proc dbo.sqlBackup (
 @method varchar(50) = 'backup',
 @brwid int = null,
 @backupTime int = null,
 @areYouSure varchar(5) = 'NO',
 @returnRows varchar(5) = 'False',
 @useSqlCompression varchar(5) = null,
 @fileName varchar(max) = null,
 @filesBlob varchar(max) = null output
) as 
begin
 set nocount on

 declare
  @backupFile varchar(max),
  @sql varchar(max),
  @database varchar(50) = db_name(),
  @backupJobName varchar(100) = 'backup',
  @jobId BINARY(16),
  @jobSQL nvarchar(1000) = 'exec dbo.sqlBackup @method = ''backup''',
  @jobStatus int,
  @backupTimeString varchar(50) = dbo.time24(@backupTime), -- right('00' + cast(datepart(hour,dbo.time2(@backupTime)) as varchar),2)
--   + right('00' + cast(datepart(minute,dbo.time2(@backupTime)) as varchar),2) + '00',
  @pathAndFileName varchar(max),
  @cmd varchar(8000),
  @cmdOutput varchar(8000),
  @gitRepo varchar(max) = (select path from dbo.paths() where name = 'gitRepo'),
  @compresskeyLog varchar(5) = dbo.settingsF('backup.CompressKeyLog','TRUE'),
  @retainBackup int = dbo.settingsF('backup.retainBackups','14')

 set @useSqlCompression = coalesce(@useSqlCompression,dbo.settingsF('backup.sqlCompression','TRUE'))
   

-- use the kts menu to ftp the backup file...
 if @method = 'ktsftp'
 begin
  set @cmd = @gitRepo + '\kts.bat ftp ' + @filename
  exec dbo.logit @@procid, 'FTP... @cmd', @cmd
  exec @cmdOutput = master..xp_cmdshell @cmd, no_output
  exec dbo.logit @@procid, 'Done!... @cmdOutput', @cmdOutput
 end

-- just a one time backup
 if @method = 'backup'
 begin


-- compress keyLog
 if @compressKeyLog='True'
   begin
    delete from keylog where id<(select min(id) from (select top 100 id from keyLog order by id desc) data)
   end
 
  select @backupFile = path from dbo.paths() where name = 'backup'

  select @sql = 'backup database ' + db_name() + ' to disk=''' + @backupFile + ''' with retaindays=0, INIT'
   + case when @useSqlCompression = 'TRUE' then ', compression' else '' end
  exec dbo.logit @@procid, @sql
  exec(@sql)

--- remove unretained backups
 declare @backups table (id int,pathAndFileName varchar(1000),modifiedDate varchar(50))
  insert @backups
   select substring(cast(brwId as varchar),2,30),pathAndFileName,modifiedDate From dbo.sqlBackupBRW() where LEFT(cast(brwid as varchar),1)='9'

 select @retainBackup = (MAX(id) - @retainBackup) from @backups 
 
 delete from @backups where id > @retainBackup

 declare @tokenId int
  while exists (select * from @backups)
   begin
     exec dbo.logit @@procid, 'deleting backup @retainBackup', @retainBackup
    select @tokenId = id from @backups order by id 
    if @tokenId>0
    begin
     exec dbo.logit @@procid, 'deleting backup @tokenId', @tokenId
     exec dbo.sqlBackup @method='destroy', @brwid=@tokenId, @areYouSure='yes'
     delete from @backups where id = @tokenId
    end
   end

  if @returnRows = 'TRUE'
   select @sql as result

  return
 end

 if @method in ('destroy') and @brwid is not null
 begin

   select @pathAndFileName = pathAndFileName From dbo.sqlBackupBRW() where brwid = '9' + cast(@brwid as varchar)
   if @areYouSure = 'NO'
   begin
    select '@code=2;@message=Are you sure you want to destroy|' + @pathAndFileName + ' ?;'
    return
   end
   if @areYouSure = 'YES'
   begin
    set @cmd = 'del ' + @pathAndFileName
    exec @cmdOutput = master..xp_cmdshell @cmd, no_output
    exec dbo.logit @@procid, '@cmdOutput', @cmdOutput
   end

   return
 end

 if @method in ('show')
 begin
  declare
   @backupFolder varchar(max)
   select @backupFolder = path From dbo.paths() where name = 'backupPath'
   select * from dbo.dirFiles(@backupFolder,@database+'_%')
   return
 end

 if @method = 'executeJob'
 begin
  exec dbo.sqlBackup
  return
 end

 if @method = 'deleteJob'
 begin
  exec dbo.scheduledTasksControl @method = 'delete', @name = @backupJobName
 end

 if @method = 'createJob'
 begin
  declare @backupCommandString varchar(max) = 'kts backupNow'
  exec dbo.scheduledTasksControl
   @method = 'create',
   @name = @backupJobName,
   @frequency = 'daily',
   @time = @backupTimeString,
   @command = @backupCommandString
 end

end